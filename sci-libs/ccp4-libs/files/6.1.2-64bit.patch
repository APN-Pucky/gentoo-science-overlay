diff --git a/ccp4-6.1.2/lib/DiffractionImage/Rigaku/RaxisImage.h b/ccp4-6.1.2/lib/DiffractionImage/Rigaku/RaxisImage.h
index e02b72b..8a9611c 100755
--- a/ccp4-6.1.2/lib/DiffractionImage/Rigaku/RaxisImage.h
+++ b/ccp4-6.1.2/lib/DiffractionImage/Rigaku/RaxisImage.h
@@ -50,6 +50,7 @@
 #include <iostream>
 #include <fstream>
 #include <sstream>
+#include <stdint.h>
 
 /****************************************************************************
  *                               Definitions                                *
@@ -92,7 +93,7 @@ struct RigakuHeader {
    float crnt;         /* generator current (mA) */
    char  focs[12];     /* focus info */
    char  optc[80];     /* xray memo */
-   long  cyld;         /* IP shape, 0=flat,1=cylinder */
+   int32_t  cyld;         /* IP shape, 0=flat,1=cylinder */
    float weis;         /* Weissenberg oscillation 1 */
    char  res2[56];     /* reserved space for future use */
 
@@ -101,7 +102,7 @@ struct RigakuHeader {
    float phi0;         /* datum phi angle (deg) */
    float phis;         /* phi oscillation start angle (deg) */
    float phie;         /* phi oscillation end angle (deg) */
-   long  oscn;         /* frame number */
+   int32_t  oscn;         /* frame number */
    float fext;         /* exposure time (min) */
    float drtx;         /* direct beam X position */
    float drtz;         /* direct beam Z position */
@@ -113,31 +114,31 @@ struct RigakuHeader {
                        /* This space is now used for storing the scan
                           template information - tlh, 01 Feb 1999 */
    
-   long  xpxl;         /* number of pixels in X direction */
-   long  zpxl;         /* number of pixels in Z direction */
+   int32_t  xpxl;         /* number of pixels in X direction */
+   int32_t  zpxl;         /* number of pixels in Z direction */
    float xsiz;         /* size of pixel in X direction (mm) */
    float zsiz;         /* size of pixel in Z direction (mm) */
-   long  rlng;         /* record length (bytes) */
-   long  rnum;         /* number of records (lines) in image */
-   long  ipst;         /* starting line number */
-   long  ipnm;         /* IP number */
+   int32_t  rlng;         /* record length (bytes) */
+   int32_t  rnum;         /* number of records (lines) in image */
+   int32_t  ipst;         /* starting line number */
+   int32_t  ipnm;         /* IP number */
    float rato;         /* photomultiplier output hi/lo ratio */
    float ft_1;         /* fading time, end of exposure to start of read */
    float ft_2;         /* fading time, end of exposure to end of read */
    char  host[10];     /* type of computer (IRIS, VAX) => endian */
    char  ip[10];       /* type of IP */
-   long  dr_x;         /* horizontal scanning code: 0=left->right, 1=>right->left */
-   long  dr_z;         /* vertical scanning code: 0=down->up, 1=up->down */
-   long  drxz;	        /* front/back scanning code: 0=front, 1=back */
+   int32_t  dr_x;         /* horizontal scanning code: 0=left->right, 1=>right->left */
+   int32_t  dr_z;         /* vertical scanning code: 0=down->up, 1=up->down */
+   int32_t  drxz;	        /* front/back scanning code: 0=front, 1=back */
    float shft;         /* pixel shift, R-AXIS V */
    float ineo;         /* intensity ratio E/O R-AXIS V */
-   long  majc;         /* magic number to indicate next values are legit */
-   long  naxs;         /* Number of goniometer axes */
+   int32_t  majc;         /* magic number to indicate next values are legit */
+   int32_t  naxs;         /* Number of goniometer axes */
    float gvec[5][3];   /* Goniometer axis vectors */
    float gst[5];       /* Start angles for each of 5 axes */
    float gend[5];      /* End angles for each of 5 axes */
    float goff[5];      /* Offset values for each of 5 axes */
-   long  saxs;         /* Which axis is the scan axis? */
+   int32_t  saxs;         /* Which axis is the scan axis? */
    char  gnom[40];     /* Names of the axes (space or comma separated?) */
 
 /*
@@ -148,17 +149,17 @@ struct RigakuHeader {
    char  file[16];     /* */
    char  cmnt[20];     /* */
    char  smpl[20];     /* */
-   long  iext;         /* */
-   long  reso;         /* */
-   long  save;         /* */
-   long  dint;         /* */
-   long  byte;         /* */
-   long  init;         /* */
-   long  ipus;         /* */
-   long  dexp;         /* */
-   long  expn;         /* */
-   long  posx[20];     /* */
-   long  posy[20];     /* */
+   int32_t  iext;         /* */
+   int32_t  reso;         /* */
+   int32_t  save;         /* */
+   int32_t  dint;         /* */
+   int32_t  byte;         /* */
+   int32_t  init;         /* */
+   int32_t  ipus;         /* */
+   int32_t  dexp;         /* */
+   int32_t  expn;         /* */
+   int32_t  posx[20];     /* */
+   int32_t  posy[20];     /* */
    int   xray;         /* */
    char  res5[768];    /* reserved space for future use */
 };
@@ -213,10 +214,10 @@ bool ReadImageBuffer(std::ifstream &InputFile,unsigned short * const pImageBuffe
    // is 2 bytes.
 unsigned short Swap(unsigned short Value);
 
-   // This routine swaps the long <VAR>Value</VAR> so that the endianness 
+   // This routine swaps the int32_t <VAR>Value</VAR> so that the endianness 
    // of <VAR>Value</VAR> is reversed and then returns the swapped value.
-   // This routine assumes that the size of a long is 4 bytes.
-long Swap(long Value);
+   // This routine assumes that the size of a int32_t is 4 bytes.
+int32_t Swap(int32_t Value);
 
    // This routine swaps the float <VAR>Value</VAR> so that the endianness 
    // of <VAR>Value</VAR> is reversed and then returns the swapped value.
@@ -225,14 +226,14 @@ long Swap(long Value);
 float Swap(float Value);
 
    // This routine swaps the values in a Rigaku-style header,
-   // <VAR>Header</VAR> so that the endianness of the <CODE>long</CODE>
+   // <VAR>Header</VAR> so that the endianness of the <CODE>int32_t</CODE>
    // and </CODE>float</CODE> is reversed.
 void Swap(RigakuHeader &Header);
   
-   // This routine returns a long containing the actual value of a packed
+   // This routine returns a int32_t containing the actual value of a packed
    // R-AXIS image pixel, <VAR>PixelValue</VAR>.  The Rigaku-style header
    // contains information concerning the packing scheme used.
-long UnPackPixelValue(const RigakuHeader &Header,
+int32_t UnPackPixelValue(const RigakuHeader &Header,
                       const unsigned short PixelValue);
 
    // This routine writes out pixel values for some prefined pixel positions
diff --git a/ccp4-6.1.2/lib/DiffractionImage/Rigaku/ReadRAXISImages.cpp b/ccp4-6.1.2/lib/DiffractionImage/Rigaku/ReadRAXISImages.cpp
index 882d93d..3df1918 100755
--- a/ccp4-6.1.2/lib/DiffractionImage/Rigaku/ReadRAXISImages.cpp
+++ b/ccp4-6.1.2/lib/DiffractionImage/Rigaku/ReadRAXISImages.cpp
@@ -87,7 +87,7 @@ bool ReadHeader(std::ifstream &InputFile,
 
    // Read the additional padding in the header
 
-   long size = Header.rlng-MinimumRigakuHeaderLength;
+   int32_t size = Header.rlng-MinimumRigakuHeaderLength;
    p = new char [size];
    InputFile.read(p,size);
    delete [] p;
@@ -108,7 +108,7 @@ bool ReadImageBuffer(std::ifstream &InputFile,unsigned short * const pImageBuffe
    // 2 bytes/pixel.
    RigakuHeader Header;
    ReadHeader(InputFile, Header);
-   long size = Header.rlng*Header.rnum/2;
+   int32_t size = Header.rlng*Header.rnum/2;
 
    // Read in the data.
 
@@ -153,9 +153,9 @@ unsigned short Swap(const unsigned short Value)
 
 /****************************************************************************
  ****************************************************************************/
-long Swap(const long Value)
+int32_t Swap(const int32_t Value)
 {
-   long swap = Value;
+   int32_t swap = Value;
    char *p = reinterpret_cast<char *>(&swap);
 
    char tmp = p[0];
@@ -192,7 +192,7 @@ float Swap(const float Value)
 void Swap(RigakuHeader &Header)
 {
 
-// Swap the bytes in the long elements of the header.
+// Swap the bytes in the int32_t elements of the header.
 
    Header.cyld = Swap(Header.cyld);
    Header.oscn = Swap(Header.oscn);
@@ -257,7 +257,7 @@ void Swap(RigakuHeader &Header)
 
 /****************************************************************************
  ****************************************************************************/
-long UnPackPixelValue(const RigakuHeader &Header,
+int32_t UnPackPixelValue(const RigakuHeader &Header,
                       const unsigned short PixelValue)
 {
    // Pixels are packed so that if the most significant bit is set, then
@@ -274,7 +274,7 @@ long UnPackPixelValue(const RigakuHeader &Header,
 
    // We only need to use the lower 15 bits of the value to uncompress it.
 
-   long Value = 0x7fff&PixelValue;
+   int32_t Value = 0x7fff&PixelValue;
 
    // Shift the value by the ratio in the header.
 
@@ -296,7 +296,7 @@ void OutputSamplePixelValues(const RigakuHeader &Header,
    std::cout << "   First pixel (0," << Header.ipst << ") in image = " << 
                 UnPackPixelValue(Header,*pImageBuffer) << std::endl;
 
-   long index = (Header.rnum/2-1)*Header.xpxl+(Header.xpxl/2-1);
+   int32_t index = (Header.rnum/2-1)*Header.xpxl+(Header.xpxl/2-1);
    std::cout << "   Middle pixel (" << Header.xpxl/2 << ',' << 
                  Header.rnum/2+Header.ipst << ") in image = " << 
                  UnPackPixelValue(Header,pImageBuffer[index]) << std::endl;
