From 9e3436c298d65a5867920b0de0d3920972465407 Mon Sep 17 00:00:00 2001
From: Ned Bass <bass6@llnl.gov>
Date: Thu, 30 Jan 2014 14:56:20 -0800
Subject: [PATCH 01/13] LU-4554 lfsck: old single-OI MDT always scrubbed

Old ldiskfs MDT's that contain a single OI container named "oi.16"
trigger an automatic OI scrub on each restart.  This is because
osd_oi_table_open() gets ENOENT opening "oi.16.0" and consequently
sets bit 0 in scrub_file::sf_oi_bitmap.  This bit indicates the OI
container 0 needs to be recreated, and it triggers a scrub in
osd_fid_lookup() for lookups that fail with ENOENT.  Fix this by
clearing the bit in osd_oi_init() after a successful open of
"oi.16".

Signed-off-by: Ned Bass <bass6@llnl.gov>
Change-Id: Ie69223d3f8289c90de46f9afe0a2de0e0625b0f6
Reviewed-on: http://review.whamcloud.com/9067
Tested-by: Jenkins
Reviewed-by: Andreas Dilger <andreas.dilger@intel.com>
Tested-by: Maloo <hpdd-maloo@intel.com>
Reviewed-by: James Nunez <james.a.nunez@intel.com>
Reviewed-by: Fan Yong <fan.yong@intel.com>
---
 lustre/osd-ldiskfs/osd_oi.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/lustre/osd-ldiskfs/osd_oi.c b/lustre/osd-ldiskfs/osd_oi.c
index 6e690be..b4bfb9a 100644
--- a/lustre/osd-ldiskfs/osd_oi.c
+++ b/lustre/osd-ldiskfs/osd_oi.c
@@ -368,6 +368,7 @@ int osd_oi_init(struct osd_thread_info *info, struct osd_device *osd)
 	/* if previous failed then try found single OI from old filesystem */
 	rc = osd_oi_open(info, osd, OSD_OI_NAME_BASE, &oi[0], false);
 	if (rc == 0) { /* found single OI from old filesystem */
+		ldiskfs_clear_bit(0, sf->sf_oi_bitmap);
 		if (sf->sf_success_count == 0)
 			/* XXX: There is one corner case that if the OI_scrub
 			 *	file crashed or lost and we regard it upgrade,
-- 
1.8.5.3

