diff -urN amber11//AmberTools/src/cpptraj/src/Action_Center.cpp amber11.new//AmberTools/src/cpptraj/src/Action_Center.cpp
--- amber11//AmberTools/src/cpptraj/src/Action_Center.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Center.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -72,7 +72,7 @@
 // else
 //    mass = NULL;
 
-  if (!origin && P->ifbox==0) {
+  if (!origin && P->BoxType==0) {
     mprintf("    Error: Center::setup: Box center specified but no box information.\n");
     //fprintf(stdout,"                            Centering on origin.\n");
     return 1;
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Closest.cpp amber11.new//AmberTools/src/cpptraj/src/Action_Closest.cpp
--- amber11//AmberTools/src/cpptraj/src/Action_Closest.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Closest.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -181,8 +181,8 @@
   // NOTE: Should box be figured out from read-in coords?
   imageType = 0;
   if (!noimage) {
-    imageType = P->ifbox;
-    if (P->ifbox==0) {
+    imageType = P->BoxType;
+    if (P->BoxType==0) {
         mprintf("    Warning: Closest::setup: ");
         mprintf(" Imaging specified but no box information in prmtop %s\n",P->parmName);
         mprintf("             No imaging can occur..\n");
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Distance.cpp amber11.new//AmberTools/src/cpptraj/src/Action_Distance.cpp
--- amber11//AmberTools/src/cpptraj/src/Action_Distance.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Distance.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -68,6 +68,11 @@
   return 0;
 }
 
+/*
+ * Distance::setup()
+ * Determine what atoms each mask pertains to for the current parm file.
+ * Also determine whether imaging should be performed.
+ */
 int Distance::setup() {
 
   if ( Mask1.SetupMask(P,debug) ) return 1;
@@ -89,8 +94,8 @@
   // Check imaging - check box based on prmtop box
   imageType = 0;
   if (!noimage) {
-    imageType = P->ifbox;
-    if (P->ifbox==0 && debug>0) {
+    imageType = P->BoxType;
+    if (P->BoxType==0 && debug>0) {
       mprintf("    Warning: No box info in %s, disabling imaging.\n",P->parmName);
     }
   }
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Image.cpp amber11.new//AmberTools/src/cpptraj/src/Action_Image.cpp
--- amber11//AmberTools/src/cpptraj/src/Action_Image.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Image.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -98,14 +98,14 @@
     useMass = false;
   }
 
-  if (P->ifbox==0) {
+  if (P->BoxType==0) {
     mprintf("    Error: Image::setup: Parm %s does not contain box information.\n",
             P->parmName);
     return 1;
   }
 
   ortho = false;  
-  if (P->ifbox==1 && triclinic==OFF) ortho=true;
+  if (P->BoxType==1 && triclinic==OFF) ortho=true;
 
   if (triclinic == FAMILIAR) {
     if (ComMask!=NULL) {
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Outtraj.cpp amber11.new//AmberTools/src/cpptraj/src/Action_Outtraj.cpp
--- amber11//AmberTools/src/cpptraj/src/Action_Outtraj.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Outtraj.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -6,6 +6,9 @@
 // CONSTRUCTOR
 Outtraj::Outtraj() {
   //fprintf(stderr,"Outtraj Con\n");
+  min=0.0;
+  max=0.0;
+  Dset=NULL;
 } 
 
 // DESTRUCTOR
@@ -13,11 +16,40 @@
 
 /*
  * Outtraj::init()
- * Action wrapper for trajout
+ * Action wrapper for trajout.
+ * Expected call: outtraj <filename> [ trajout args ] 
+ *                        [maxmin <dataset> min <min> max <max>
  */
 int Outtraj::init() {
+  char *datasetName;
+
+#ifdef MPI
+  mprintf("ERROR: OUTTRAJ currently not functional with MPI.\n");
+  return 1;
+#endif
+
+  mprintf("    OUTTRAJ: Will write to [%s]\n",A->Arg(1));
+  outtraj.SetDebug(debug);
+  // If maxmin, get the name of the dataset as well as the max and min values.
+  datasetName = A->getKeyString("maxmin",NULL);
+  if (datasetName!=NULL) {
+    Dset = DSL->Get(datasetName);
+    if (Dset==NULL) {
+      mprintf("Error: Outtraj maxmin: Could not get dataset %s\n",datasetName);
+      return 1;
+    } else {
+      // Currently dont allow for string datasets
+      if (Dset->Type()==STRING) {
+        mprintf("Error: Outtraj maxmin: String dataset (%s) not supported.\n",datasetName);
+        return 1;
+      }
+      max = A->getKeyDouble("max",0.0);
+      min = A->getKeyDouble("min",0.0);
+      mprintf("             maxmin: Printing trajectory frames based on %lf <= %s <= %lf\n",
+              min, datasetName, max);
+    }
+  }
 
-  mprintf("    OUTTRAJ: [%s]\n",A->ArgLine());
   return ( outtraj.Add(A,PFL,worldsize) );
 } 
 
@@ -33,8 +65,32 @@
  * Outtraj::action()
  */
 int Outtraj::action() {
+  double dVal;
+  int iVal;
 
-  return ( outtraj.Write(currentFrame, F, P) );
+  // If dataset defined, check if frame is within max/min
+  if (Dset!=NULL) {
+    if (Dset->Type() == DOUBLE) {
+      if (Dset->Get(&dVal, currentFrame)) return 1;
+    } else if (Dset->Type() == INT) {
+      if (Dset->Get(&iVal, currentFrame)) return 1;
+      dVal = (double) iVal;
+    } else
+      return 1;
+    //mprintf("DBG: maxmin: dVal = %lf\n",dVal);
+    // If value from dataset not within min/max, exit now.
+    if (dVal < min || dVal > max) return 0;
+  }
+  if ( outtraj.Write(currentFrame, F, P) != 0 ) return 1;
+  return 0;
 } 
 
+/*
+ * Outtraj::print()
+ * Close trajectory.
+ */
+void Outtraj::print() {
+  mprintf("  OUTTRAJ: [%s] Wrote %i frames.\n",A->Arg(1),outtraj.front()->CurrentFrame());
+  outtraj.Close();
+}
 
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Outtraj.h amber11.new//AmberTools/src/cpptraj/src/Action_Outtraj.h
--- amber11//AmberTools/src/cpptraj/src/Action_Outtraj.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Outtraj.h	2011-05-19 18:35:57.000000000 +0300
@@ -6,6 +6,9 @@
 
 class Outtraj: public Action {
     TrajoutList outtraj;
+    double max;
+    double min;
+    DataSet *Dset;
   public:
     Outtraj();
     ~Outtraj();
@@ -13,5 +16,6 @@
     int init();
     //int setup();
     int action();
+    void print();
 };
 #endif
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Rms2d.cpp amber11.new//AmberTools/src/cpptraj/src/Action_Rms2d.cpp
--- amber11//AmberTools/src/cpptraj/src/Action_Rms2d.cpp	1970-01-01 03:00:00.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Rms2d.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -0,0 +1,71 @@
+// Rms2d 
+#include "Action_Rms2d.h"
+#include "CpptrajStdio.h"
+
+// CONSTRUCTOR
+Rms2d::Rms2d() {
+  //fprintf(stderr,"Rms2d Con\n");
+  nofit=false;
+  useMass=false;
+} 
+
+// DESTRUCTOR
+Rms2d::~Rms2d() { }
+
+/*
+ * Rms2d::init()
+ * Expected call: rms2d <mask> <refmask> [rmsout filename] [mass] [nofit]
+ * Dataset name will be the last arg checked for. Check order is:
+ *    1) Keywords
+ *    2) Masks
+ *    3) Dataset name
+ */
+int Rms2d::init() {
+  char *mask0, *maskRef;
+
+  // Get keywords
+  nofit = A->hasKey("nofit");
+  useMass = A->hasKey("mass");
+  rmsdFile = A->getKeyString("rmsout",NULL);
+
+  // Get the RMS mask string for frames
+  mask0 = A->getNextMask();
+  FrameMask.SetMaskString(mask0);
+  // Get RMS mask string for reference
+  maskRef = A->getNextMask();
+  // If no reference mask specified, make same as RMS mask
+  if (maskRef==NULL) maskRef=mask0;
+  RefMask.SetMaskString(maskRef);
+
+  mprintf("    RMS2D: (%s) to (%s)",FrameMask.maskString,RefMask.maskString);
+  if (nofit)
+    mprintf(" (no fitting)");
+  if (useMass)
+    mprintf(" (mass-weighted)");
+  if (rmsdFile!=NULL) 
+    mprintf(" output to %s",rmsdFile);
+  mprintf("\n");
+
+  return 0;
+}
+
+/*
+ * Rms2d::setup()
+ * Not important for Rms2d, initial pass is only for storing frames.
+ */
+int Rms2d::setup() {
+  return 0;  
+}
+
+/*
+ * Rms2d::action()
+ * Store current frame as a reference frame.
+ */
+int Rms2d::action() {
+
+  ReferenceFrames.Add(F,P);
+  
+  return 0;
+} 
+
+
diff -urN amber11//AmberTools/src/cpptraj/src/Action_Rms2d.h amber11.new//AmberTools/src/cpptraj/src/Action_Rms2d.h
--- amber11//AmberTools/src/cpptraj/src/Action_Rms2d.h	1970-01-01 03:00:00.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Action_Rms2d.h	2011-05-19 18:35:57.000000000 +0300
@@ -0,0 +1,21 @@
+#ifndef INC_ACTION_RMS2D_H
+#define INC_ACTION_RMS2D_H
+// Rms2d
+#include "Action.h"
+
+class Rms2d: public Action {
+    FrameList ReferenceFrames;
+    bool nofit;
+    bool useMass;
+    AtomMask RefMask;
+    AtomMask FrameMask;
+    char *rmsdFile;
+  public:
+    Rms2d();
+    ~Rms2d();
+
+    int init();
+    int setup();
+    int action();
+};
+#endif
diff -urN amber11//AmberTools/src/cpptraj/src/AmberNetcdf.cpp amber11.new//AmberTools/src/cpptraj/src/AmberNetcdf.cpp
--- amber11//AmberTools/src/cpptraj/src/AmberNetcdf.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberNetcdf.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -49,6 +49,7 @@
  * and close calls.
  */
 void AmberNetcdf::close() {
+  if (ncid<0) return;
   checkNCerr(nc_close(ncid),"Closing netcdf file.");
   if (debug>0) rprintf("Successfully closed ncid %i\n",ncid);
   ncid=-1;
@@ -92,8 +93,10 @@
  * Open the netcdf file, read all dimension and variable IDs, close. 
  */
 int AmberNetcdf::SetupRead() {
-  char *attrText; // For checking conventions and version 
-  int spatial; // For checking spatial dimensions
+  char *attrText;            // For checking conventions and version 
+  int spatial;               // For checking spatial dimensions
+  double box[6];             // For checking box type
+  size_t start[3], count[3]; // For checking box type
 
   if (open()) return 1;
 
@@ -147,15 +150,15 @@
   if ( nc_inq_varid(ncid,"cell_lengths",&cellLengthVID)==NC_NOERR ) {
     if (checkNCerr(nc_inq_varid(ncid,"cell_angles",&cellAngleVID),
       "Getting cell angles.")!=0) return 1;
-    if (debug>0) mprintf("  Netcdf Box information found.\n"); 
-    if (P->ifbox==0) {
-      mprintf("Warning: Netcdf file contains box info but no box info found\n");
-      mprintf("         in associated parmfile %s; defaulting to orthogonal.\n",
-              P->parmName);
-      isBox=1;
-    } else {
-      isBox=P->ifbox;
-    }
+    if (debug>0) mprintf("  Netcdf Box information found.\n");
+    // Determine box type from angles
+    start[0]=0; start[1]=0; start[2]=0; 
+    count[0]=1; count[1]=3; count[2]=0;
+    if ( checkNCerr(nc_get_vara_double(ncid, cellLengthVID, start, count, box),
+                    "Getting cell lengths.")!=0 ) return 1;
+    if ( checkNCerr(nc_get_vara_double(ncid, cellAngleVID, start, count, box+3),
+                    "Getting cell angles.")!=0 ) return 1;
+    CheckBoxType(box);
   } 
 
   // Replica Temperatures
@@ -258,7 +261,7 @@
     "Defining cell angular variable.")) return 1;
 
   // Box Info
-  if (isBox>0) {
+  if (BoxType!=0) {
     dimensionID[0]=frameDID;
     dimensionID[1]=cell_spatialDID;
     if (checkNCerr(nc_def_var(ncid,"cell_lengths",NC_DOUBLE,2,dimensionID,&cellLengthVID),
@@ -362,7 +365,7 @@
                   "Getting frame %i",set)!=0 ) return 1;
 
   // Read box info 
-  if (isBox!=0) {
+  if (BoxType!=0) {
     count [1]=3;
     count [2]=0;
     if ( checkNCerr(nc_get_vara_double(ncid, cellLengthVID, start, count, F->box),
@@ -399,7 +402,7 @@
   F->frameToFloat(Coord);
 
   // write coords
-  start[0]=set;
+  start[0]=currentFrame;
   start[1]=0;
   start[2]=0;
   count[0]=1;
@@ -409,7 +412,7 @@
     "Netcdf Writing frame %i",set)) return 1;
 
   // write box
-  if (isBox>0 && cellLengthVID!=-1) {
+  if (BoxType!=0 && cellLengthVID!=-1) {
     count[1]=3;
     count[2]=0;
     if (checkNCerr(nc_put_vara_double(ncid,cellLengthVID,start,count,F->box),
@@ -427,6 +430,8 @@
   
   nc_sync(ncid); // Necessary after every write??
 
+  currentFrame++;
+
   return 0;
 }  
 
diff -urN amber11//AmberTools/src/cpptraj/src/AmberParm.cpp amber11.new//AmberTools/src/cpptraj/src/AmberParm.cpp
--- amber11//AmberTools/src/cpptraj/src/AmberParm.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberParm.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -1,6 +1,12 @@
 /* AmberParm.cpp
- * Class that holds parameter information. Can be read in from Amber Topology
- * or PDB files.
+ * Class that holds parameter information. Can be read in from Amber Topology,
+ * PDB, or Mol2 files (implemented in the ReadParmXXX functions). The following
+ * parameters of AmberParm must always be set:
+ *   The NATOM, NRES, and IFBOX entries of the values array.
+ *   The names, resnames, resnums arrays.
+ *   The natom and nres variables.
+ * NOTES:
+ *   Eventually make the mol2 read parm function use the AddBond function.
  */
 #include <cstdlib>
 #include <cstring>
@@ -11,7 +17,7 @@
 #include "CpptrajStdio.h"
 
 #define AMBERPOINTERS 31
-
+#define TRUNCOCTBETA 109.4712206344906917365733534097672
 #define ELECTOAMBER 18.2223
 #define AMBERTOELEC 1/ELECTOAMBER
 // =============================================================
@@ -203,7 +209,9 @@
   bondsh=NULL;   
   types=NULL;   
   atomsPerMol=NULL; 
-  Box=NULL;    
+  Box[0]=0.0; Box[1]=0.0; Box[2]=0.0;
+  Box[3]=0.0; Box[4]=0.0; Box[5]=0.0;
+  BoxType=0; 
   pindex=0;      
   parmFrames=0; 
   outFrame=0;
@@ -217,7 +225,6 @@
   solventMoleculeStop=NULL;
   natom=0;      
   nres=0; 
-  ifbox=0; 
   parmName=NULL; 
   SurfaceInfo=NULL;
 }
@@ -234,7 +241,6 @@
   if (bonds!=NULL) free(bonds);
   if (bondsh!=NULL) free(bondsh);
   if (atomsPerMol!=NULL) free(atomsPerMol);
-  if (Box!=NULL) free(Box);
   if (solventMoleculeStart!=NULL) free(solventMoleculeStart);
   if (solventMoleculeStop!=NULL) free(solventMoleculeStop);
   if (solventMask!=NULL) free(solventMask);
@@ -271,54 +277,7 @@
   return NULL;
 }
 
-/* 
- * AmberParm::OpenParm()
- * Attempt to open file and read in parameters.
- */
-int AmberParm::OpenParm(char *filename) {
-  if ( File.SetupFile(filename,READ,UNKNOWN_FORMAT, UNKNOWN_TYPE,debug) ) return 1;
-
-  // Copy parm filename to parmName. Separate from File.filename in case of stripped parm
-  parmName=(char*) malloc( (strlen(File.basefilename)+1) * sizeof(char));
-  strcpy(parmName,File.basefilename);
-
-  if ( File.OpenFile() ) return 1;
-
-  switch (File.fileFormat) {
-    case AMBERPARM : if (ReadParmAmber()) return 1; break;
-    case PDBFILE   : if (ReadParmPDB()  ) return 1; break;
-    case MOL2FILE  : if (ReadParmMol2() ) return 1; break;
-    default: 
-      rprintf("Unknown parameter file type: %s\n",File.filename);
-      return 1;
-  }
-
-  File.CloseFile();
-
-  // Create a last dummy residue in resnums that holds natom, which would be
-  // the atom number of the next residue if it existed. Atom #s in resnums
-  // should correspond with cpptraj atom #s (start from 0) instead of Amber
-  // atom #s (start from 1). 
-  // Do this to be consistent with ptrajmask selection behavior - saves an 
-  // if-then statement.
-  resnums=(int*) realloc(resnums,(nres+1)*sizeof(int));
-  resnums[nres]=natom;
-  // DEBUG
-  //fprintf(stdout,"==== DEBUG ==== Resnums for %s:\n",File.filename);
-  //for (err=0; err<nres; err++) 
-  //  fprintf(stdout,"    %i: %i\n",err,resnums[err]);
-
-  // Set up solvent information
-  SetSolventInfo();
-
-  if (debug>0) {
-    mprintf("  Number of atoms= %i\n",natom);
-    mprintf("  Number of residues= %i\n",nres);
-  }
-
-  return 0;
-}
-
+// ---------========= ROUTINES PERTAINING TO SURFACE AREA =========---------
 /*
  * AmberParm::AssignLCPO()
  * Assign parameters for LCPO method. All radii are incremented by 1.4 Ang.
@@ -478,6 +437,7 @@
   return 0;
 }
 
+// ---------========= ROUTINES PERTAINING TO SOLVENT INFO =========---------
 /*
  * AmberParm::SetSolventInfo()
  * Assuming atomsPerMol has been read in, set solvent information.
@@ -536,7 +496,56 @@
 
   return 0; 
 }
-     
+    
+// --------========= ROUTINES PERTAINING TO READING PARAMETERS =========--------
+/* 
+ * AmberParm::OpenParm()
+ * Attempt to open file and read in parameters.
+ */
+int AmberParm::OpenParm(char *filename) {
+  if ( File.SetupFile(filename,READ,UNKNOWN_FORMAT, UNKNOWN_TYPE,debug) ) return 1;
+
+  // Copy parm filename to parmName. Separate from File.filename in case of stripped parm
+  parmName=(char*) malloc( (strlen(File.basefilename)+1) * sizeof(char));
+  strcpy(parmName,File.basefilename);
+
+  if ( File.OpenFile() ) return 1;
+
+  switch (File.fileFormat) {
+    case AMBERPARM : if (ReadParmAmber()) return 1; break;
+    case PDBFILE   : if (ReadParmPDB()  ) return 1; break;
+    case MOL2FILE  : if (ReadParmMol2() ) return 1; break;
+    default: 
+      rprintf("Unknown parameter file type: %s\n",File.filename);
+      return 1;
+  }
+
+  File.CloseFile();
+
+  // Create a last dummy residue in resnums that holds natom, which would be
+  // the atom number of the next residue if it existed. Atom #s in resnums
+  // should correspond with cpptraj atom #s (start from 0) instead of Amber
+  // atom #s (start from 1). 
+  // Do this to be consistent with ptrajmask selection behavior - saves an 
+  // if-then statement.
+  resnums=(int*) realloc(resnums,(nres+1)*sizeof(int));
+  resnums[nres]=natom;
+  // DEBUG
+  //fprintf(stdout,"==== DEBUG ==== Resnums for %s:\n",File.filename);
+  //for (err=0; err<nres; err++) 
+  //  fprintf(stdout,"    %i: %i\n",err,resnums[err]);
+
+  // Set up solvent information
+  SetSolventInfo();
+
+  if (debug>0) {
+    mprintf("  Number of atoms= %i\n",natom);
+    mprintf("  Number of residues= %i\n",nres);
+  }
+
+  return 0;
+}
+
 /* 
  * AmberParm::ReadParmAmber() 
  * Read parameters from Amber Topology file
@@ -544,6 +553,7 @@
 int AmberParm::ReadParmAmber() {
   int err, atom;
   int *solvent_pointer;
+  double *boxFromParm;
 
   if (debug>0) mprintf("Reading Amber Topology file %s\n",parmName);
 
@@ -555,7 +565,6 @@
 
   natom=values[NATOM];
   nres=values[NRES];
-  ifbox=values[IFBOX];
   if (debug>0)
     mprintf("    Amber top contains %i atoms, %i residues.\n",natom,nres);
 
@@ -583,7 +592,8 @@
   if (bonds==NULL) {mprintf("Error in bonds w/o H.\n"); err++;}
   bondsh=(int*) getFlagFileValues("BONDS_INC_HYDROGEN",values[NBONH]*3);
   if (bondsh==NULL) {mprintf("Error in bonds inc H.\n"); err++;}
-  if (ifbox>0) {
+  // Get solvent info if IFBOX>0
+  if (values[IFBOX]>0) {
     solvent_pointer=(int*) getFlagFileValues("SOLVENT_POINTERS",3);
     if (solvent_pointer==NULL) {
       mprintf("Error in solvent pointers.\n"); 
@@ -596,12 +606,20 @@
     }
     atomsPerMol=(int*) getFlagFileValues("ATOMS_PER_MOLECULE",molecules);
     if (atomsPerMol==NULL) {mprintf("Error in atoms per molecule.\n"); err++;}
-    Box=(double*) getFlagFileValues("BOX_DIMENSIONS",4);
-    if (Box==NULL) {mprintf("Error in Box information.\n"); err++;}
+    // boxFromParm = {OLDBETA, BOX(1), BOX(2), BOX(3)}
+    boxFromParm=(double*) getFlagFileValues("BOX_DIMENSIONS",4);
+    if (boxFromParm==NULL) {mprintf("Error in Box information.\n"); err++;}
+    // Determine box type: 1-Ortho, 2-Nonortho
+    SetBoxInfo(boxFromParm[0],boxFromParm[1],boxFromParm[2],boxFromParm[3]);
+    free(boxFromParm);
     if (debug>0) {
       mprintf("    %s contains box info: %i mols, first solvent mol is %i\n",
               parmName, molecules, firstSolvMol);
-      mprintf("    BOX: %lf %lf %lf %lf\n",Box[0],Box[1],Box[2],Box[3]);
+      mprintf("    BOX: %lf %lf %lf | %lf %lf %lf\n",Box[0],Box[1],Box[2],Box[3],Box[4],Box[5]);
+      if (BoxType==1)
+        mprintf("         Box is orthogonal.\n");
+      else
+        mprintf("         Box is non-orthogonal.\n");
     }
   }
 
@@ -686,6 +704,7 @@
   values = (int*) calloc(AMBERPOINTERS, sizeof(int));
   values[NATOM] = natom;
   values[NRES] = nres;
+  values[IFBOX] = 0;
 
   if (debug>0) 
     mprintf("    PDB contains %i atoms, %i residues, %i molecules.\n",
@@ -799,6 +818,7 @@
   values[NRES] = nres;
   values[NBONH] = numbondsh;
   values[MBONA] = numbonds;
+  values[IFBOX] = 0;
 
   mprintf("    Mol2 contains %i atoms, %i residues,\n", natom,nres);
   mprintf("    %i bonds to H, %i other bonds.\n", numbondsh,numbonds);
@@ -806,6 +826,61 @@
   return 0;
 }
 
+// ---------===========================================================---------
+/*
+ * AmberParm::SetBoxInfo()
+ * Given 3 box lengths and an angle determine the box type and set
+ * the box information. If called with negative beta, set no box.
+ * Currently recognized betas:
+ *   90.00 - Orthogonal
+ *  109.47 - Truncated octahedral
+ *   60.00 - Rhombic dodecahedron
+ * Any other beta just sets all angles to beta and a warning is printed.
+ */
+int AmberParm::SetBoxInfo(double beta, double bx, double by, double bz)  {
+  int ifbox=0;
+
+  // Determine box type from beta (none, ortho, non-ortho (truncated oct/triclinic)
+  if (beta<=0.0) {
+    if (BoxType>0) 
+      mprintf("    %s: Removing box information.\n",parmName);
+    BoxType=0;
+    ifbox=0;
+    Box[0]=0.0; Box[1]=0.0; Box[2]=0.0;
+    Box[3]=0.0; Box[4]=0.0; Box[5]=0.0;
+  } else if (beta == 90.0) {
+    BoxType=1;
+    ifbox=1;
+    Box[0]=bx; Box[1]=by; Box[2]=bz;
+    Box[3]=90.0; Box[4]=90.0; Box[5]=90.0;
+    if (debug>0) mprintf("    %s: Setting box to be orthogonal.\n",parmName);
+  } else if (beta > 109.47 && beta < 109.48) {
+    BoxType=2;
+    ifbox=2;
+    Box[0]=bx; Box[1]=by; Box[2]=bz;
+    //Box[3] = TRUNCOCTBETA;
+    Box[3] = beta;
+    Box[4]=Box[3]; Box[5]=Box[3];
+    if (debug>0) mprintf("    %s: Setting box to be a truncated octahedron, angle is %lf\n",
+                         parmName,Box[3]);
+  } else if (beta == 60.0) {
+    BoxType=2;
+    ifbox=1;
+    Box[0]=bx; Box[1]=by; Box[2]=bz;
+    Box[3]=60.0; Box[4]=90.0; Box[5]=60.0;
+    if (debug>0) 
+      mprintf("    %s: Setting box to be a rhombic dodecahedron, alpha=gamma=60.0, beta=90.0\n",
+              parmName);
+  } else {
+    BoxType=2;
+    ifbox=1;
+    Box[0]=bx; Box[1]=by; Box[2]=bz;
+    Box[3]=beta; Box[4]=beta; Box[5]=beta;
+    mprintf("    Warning: %s: Unrecognized box type, beta is %lf\n",beta);
+  }
+  return 0;  
+}
+
 /*
  * AmberParm::AtomInfo()
  * Print parm information for atom.
@@ -829,8 +904,8 @@
  */
 void AmberParm::Info(char *buffer) {
 
-  sprintf(buffer,"%i atoms, %i res, box %i, %i mol, %i solvent mol, %i frames",
-          natom,nres,ifbox,molecules,solventMolecules,parmFrames);
+  sprintf(buffer,"%i atoms, %i res, boxtype %i, %i mol, %i solvent mol, %i frames",
+          natom,nres,BoxType,molecules,solventMolecules,parmFrames);
 }
   
 // NOTE: The following atomToX functions do not do any memory checks!
@@ -963,6 +1038,7 @@
   return bonds;
 }
 
+// ---------===========================================================---------
 /*
  * AmberParm::modifyStateByMap()
  * Currently only intended for use with AtomMap.
@@ -1028,24 +1104,21 @@
   // Set up new parm information
   newParm->natom = this->natom;
   newParm->nres = this->nres;
-  newParm->ifbox = this->ifbox;
   newParm->parmFrames = this->parmFrames;
 
   // Give mapped parm the same pindex as original parm
   newParm->pindex = this->pindex;
 
   // Copy box information
-  if (this->Box!=NULL) {
-    newParm->Box=(double*) malloc(4*sizeof(double));
-    for (int i=0; i<4; i++)
-      newParm->Box[i] = this->Box[i];
-  }
+  for (int i=0; i<6; i++)
+    newParm->Box[i] = this->Box[i];
+  newParm->BoxType=this->BoxType;
 
   // Set values up
   // NOTE: Eventually set all pointers up?
   newParm->values[NATOM] = newParm->natom;
   newParm->values[NRES] = newParm->nres;
-  newParm->values[IFBOX] = newParm->ifbox;
+  newParm->values[IFBOX] = this->values[IFBOX];
 
   return newParm;
 }
@@ -1152,7 +1225,6 @@
   // Set up new parm information
   newParm->natom = j;
   newParm->nres = jres+1; 
-  newParm->ifbox = this->ifbox;
   newParm->parmFrames = this->parmFrames;
   if (this->molecules>0) 
     newParm->molecules = jmol+1;
@@ -1184,26 +1256,25 @@
   }
   
   // Copy box information
-  if (this->Box!=NULL) {
-    newParm->Box=(double*) malloc(4*sizeof(double));
-    for (i=0; i<4; i++)
-      newParm->Box[i] = this->Box[i];
-  }
+  for (i=0; i<6; i++)
+    newParm->Box[i] = this->Box[i];
+  newParm->BoxType=this->BoxType;
 
   // Set values up
   // NOTE: Eventually set all pointers up?
   newParm->values[NATOM] = newParm->natom;
   newParm->values[NRES] = newParm->nres;
-  newParm->values[IFBOX] = newParm->ifbox;
+  newParm->values[IFBOX] = this->values[IFBOX];
 
   mprintf("           New parmtop contains %i atoms.\n",newParm->natom);
   mprintf("                                %i residues.\n",newParm->nres);
   mprintf("                                %i molecules.\n",newParm->molecules);
-  mprintf("                                %i solvent molcules.\n",newParm->solventMolecules);
+  mprintf("                                %i solvent molecules.\n",newParm->solventMolecules);
 
   return newParm;
 }
 
+// ---------===========================================================---------
 /* 
  * AmberParm::DataToBuffer()
  * Return char buffer containing N data elements stored in I, D, or C with 
@@ -1267,6 +1338,7 @@
   char *buffer;
   int solvent_pointer[3];
   int atom;
+  double parmBox[4];
 
   if (parmName==NULL) return 1;
 
@@ -1346,7 +1418,7 @@
   }
 
   // SOLVENT POINTERS
-  if (ifbox>0) {
+  if (values[IFBOX]>0) {
     PrintFlagFormat(&outfile, "%FLAG SOLVENT_POINTERS", "%FORMAT(3I8)");
     solvent_pointer[0]=finalSoluteRes;
     solvent_pointer[1]=molecules;
@@ -1360,8 +1432,12 @@
     outfile.IO->Write(buffer, sizeof(char), BufferSize);
 
     // BOX DIMENSIONS
+    parmBox[0] = Box[4]; // beta
+    parmBox[1] = Box[0]; // boxX
+    parmBox[2] = Box[1]; // boxY
+    parmBox[3] = Box[2]; // boxZ
     PrintFlagFormat(&outfile, "%FLAG BOX_DIMENSIONS", "%FORMAT(5E16.8)");
-    buffer = DataToBuffer(buffer,"%FORMAT(5E16.8)", NULL, Box, NULL, 4);
+    buffer = DataToBuffer(buffer,"%FORMAT(5E16.8)", NULL, parmBox, NULL, 4);
     outfile.IO->Write(buffer, sizeof(char), BufferSize);
   }
 
diff -urN amber11//AmberTools/src/cpptraj/src/AmberParm.h amber11.new//AmberTools/src/cpptraj/src/AmberParm.h
--- amber11//AmberTools/src/cpptraj/src/AmberParm.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberParm.h	2011-05-19 18:35:57.000000000 +0300
@@ -75,14 +75,14 @@
     int *resnums;         // IPRES(NRES) 
     int natom;            // NATOM
     int nres;             // NRES
-    int ifbox;            // IFBOX
     int finalSoluteRes;   // IPTRES
     int molecules;        // NSPM
     int firstSolvMol;     // NSPSOL
     int *atomsPerMol;     // NSP(NSPM)
     double *mass;         // AMASS(NATOM)
     double *charge;       // CHARGE(NATOM)
-    double *Box;          // OLDBETA, BOX(1), BOX(2), BOX(3)
+    double Box[6];        // X, Y, Z, alpha, beta, gamma 
+    int BoxType;          // 0: None, 1: Orthogonal, 2: Non-orthogonal
     // From Ptraj
     char *solventMask;         // T for atoms in the solvent
     int solventMolecules;      // number of solvent molecules
@@ -96,6 +96,7 @@
     ~AmberParm();
     void ResName(char *, int);
     int OpenParm(char *);
+    int SetBoxInfo(double,double,double,double);
     int SetSurfaceInfo();
     int SetSolventInfo();
     void AtomInfo(int);
diff -urN amber11//AmberTools/src/cpptraj/src/AmberRestart.cpp amber11.new//AmberTools/src/cpptraj/src/AmberRestart.cpp
--- amber11//AmberTools/src/cpptraj/src/AmberRestart.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberRestart.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -109,7 +109,7 @@
   frameSize+=frameSize;
 
   // If box coords are present, allocate extra space for them
-  if (isBox>0) {
+  if (BoxType!=0) {
     numBoxCoords=6;
     frameSize+=((numBoxCoords*12)+1);
   }
@@ -167,13 +167,12 @@
 
   // If 0 probably at EOF. No box or velo.
 //  } else if (lineSize==0) {
-    isBox=0;
+    BoxType=0;
     hasVelocity=0;
 
   // If 36 or 72 (+1 newline) box info.
   } else if (lineSize==37 || lineSize==73) {
-    isBox=1;
-    numBoxCoords = (lineSize-1) / 12;
+    getBoxType(frameBuffer,lineSize);
     hasVelocity=0;
 
   // If filled framebuffer again, has velocity info. Check for box after velocity.
@@ -182,15 +181,14 @@
     if (File->IO->Gets(buffer,82)==0) {
       lineSize=strlen(buffer);
       if (lineSize==37 || lineSize==73) {
-        isBox=1;
-        numBoxCoords = (lineSize-1) / 12;
+        getBoxType(buffer,lineSize);
       } else {
         mprintf("Error: AmberRestart::SetupRead():\n");
         mprintf("       Expect only 3 or 6 box coords in box coord line.\n");
         return 1;
       }
     } else
-      isBox=0;
+      BoxType=0;
 
   // Otherwise, who knows what was read?
   } else {
@@ -202,12 +200,12 @@
 
   // Recalculate the frame size
   if (hasVelocity) frameSize+=frameSize;
-  if (isBox) frameSize+=( (numBoxCoords*12) + 1 );
+  if (BoxType!=0) frameSize+=( (numBoxCoords*12) + 1 );
   frameBuffer=(char*) realloc(frameBuffer, frameSize*sizeof(char));
 
   if (debug > 0) {
-    mprintf("    Amber Restart isBox=%i hasVelocity=%i numBoxCoords=%i\n",
-            isBox,hasVelocity,numBoxCoords);
+    mprintf("    Amber Restart BoxType=%i hasVelocity=%i numBoxCoords=%i\n",
+            BoxType,hasVelocity,numBoxCoords);
     mprintf("    Amber Restart frameSize= %i\n",frameSize);
   }
   
@@ -221,6 +219,20 @@
 }
 
 /*
+ * AmberRestart::getBoxType()
+ * Based on input buffer, determine box type and num box coords.
+ */
+void AmberRestart::getBoxType(char *boxline, int boxlineSize) {
+  double box[6];
+  numBoxCoords = (boxlineSize-1) / 12;
+  if (numBoxCoords>3) {
+    sscanf(boxline, "%8lf%8lf%8lf%8lf%8lf%8lf",box,box+1,box+2,box+3,box+4,box+5);
+    CheckBoxType(box);
+  } else
+    BoxType = P->BoxType;
+}
+
+/*
  * AmberRestart::getFrame()
  * Get the restart file frame. If velocities are present, read those too.
  */
@@ -251,7 +263,7 @@
     //F->V->printAtomCoord(0);
   }
   // Convert box to Frame if present
-  if (isBox) {
+  if (BoxType!=0) {
     if ( (bufferPosition = F->BufferToBox(bufferPosition, numBoxCoords, 12))==NULL ) {
       mprintf("Error: AmberRestart::getFrame: * detected in box coordinates of %s\n",
               trajfilename);
@@ -287,7 +299,7 @@
   if (F->V!=NULL)  // NOTE: Use hasVelocity in addition/instead?
     bufferPosition = F->V->FrameToBuffer(bufferPosition,"%12.7lf",12,6);
   // Write box to buffer
-  if (isBox)
+  if (BoxType!=0)
     bufferPosition = F->BoxToBuffer(bufferPosition, numBoxCoords, "%12.7lf",12);
 
   //if (seekable) fseek(fp, titleSize+(set*frameSize),SEEK_SET);
@@ -297,6 +309,8 @@
 
   File->IO->Close();
 
+  currentFrame++;
+
   return 0;
 }
 
diff -urN amber11//AmberTools/src/cpptraj/src/AmberRestart.h amber11.new//AmberTools/src/cpptraj/src/AmberRestart.h
--- amber11//AmberTools/src/cpptraj/src/AmberRestart.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberRestart.h	2011-05-19 18:35:57.000000000 +0300
@@ -14,6 +14,7 @@
 
   int SetupRead();
   int SetupWrite();
+  void getBoxType(char *, int);
 
   public:
 
diff -urN amber11//AmberTools/src/cpptraj/src/AmberRestartNC.cpp amber11.new//AmberTools/src/cpptraj/src/AmberRestartNC.cpp
--- amber11//AmberTools/src/cpptraj/src/AmberRestartNC.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberRestartNC.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -60,15 +60,8 @@
 /*
  * AmberRestartNC::open()
  * Open up Netcdf restart file and set all dimension and variable IDs.
- * This is done every time the file is opened up since Im not sure
- * the variable IDs stay the same throughout each opening.
- * Could eventually be separated.
- * NOTE: Replace attrText allocs with static buffer? 
  */
 int AmberRestartNC::open() {
-  char *attrText; // For checking conventions and version 
-  int spatial; // For checking spatial dimensions
-
   mprintf("DEBUG: AmberRestartNC::open() called for %s, ncid=%i\n",File->filename,ncid);
   // If already open, return
   if (ncid!=-1) return 0;
@@ -94,6 +87,23 @@
   // Netcdf files are always seekable
   seekable=1;
 
+  return 0;
+}
+
+/*
+ * AmberRestartNC::SetupRead()
+ * Set up netcdf restart file for reading, get all variable and dimension IDs. 
+ * Also check number of atoms against associated parmtop.
+ * NOTE: Replace attrText allocs with static buffer? 
+ */
+int AmberRestartNC::SetupRead() {
+  char *attrText; // For checking conventions and version 
+  int spatial; // For checking spatial dimensions
+  double box[6];
+  size_t start[2], count[2];
+
+  if (open()) return 1;
+
   // Get global attributes
   if (title==NULL) title = GetAttrText(ncid,NC_GLOBAL, "title");
   attrText = GetAttrText(ncid,NC_GLOBAL, "Conventions");
@@ -147,20 +157,18 @@
   mprintf("    Netcdf restart time= %lf\n",restartTime);
 
   // Box info
-  // NOTE: If no box info found in parm should really try to determine correct
-  //       box type from angles. 
   if ( nc_inq_varid(ncid,"cell_lengths",&cellLengthVID)==NC_NOERR ) {
     if (checkNCerr(nc_inq_varid(ncid,"cell_angles",&cellAngleVID),
       "Getting cell angles.")!=0) return 1;
-    if (debug>0) mprintf("  Netcdf restart Box information found.\n"); 
-    if (P->ifbox==0) {
-      mprintf("Warning: Netcdf restart file contains box info but no box info found\n");
-      mprintf("         in associated parmfile %s; defaulting to orthogonal.\n",
-              P->parmName);
-      isBox=1;
-    } else {
-      isBox=P->ifbox;
-    }
+    if (debug>0) mprintf("  Netcdf restart Box information found.\n");
+    // Determine box type from angles
+    start[0]=0; start[1]=0;
+    count[0]=3; count[1]=0; 
+    if ( checkNCerr(nc_get_vara_double(ncid, cellLengthVID, start, count, box),
+                    "Getting cell lengths.")!=0 ) return 1;
+    if ( checkNCerr(nc_get_vara_double(ncid, cellAngleVID, start, count, box+3),
+                    "Getting cell angles.")!=0 ) return 1;
+    CheckBoxType(box);
   } 
 
   // Replica Temperatures
@@ -175,15 +183,6 @@
   //int cell_spatialDID, cell_angularDID;
   //int spatialVID, cell_spatialVID, cell_angularVID;
 
-  return 0;
-}
-
-/*
- * AmberRestartNC::SetupRead()
- * Just a frontend to open for now. Also check number of atoms.
- */
-int AmberRestartNC::SetupRead() {
-  if (open()) return 1;
   if (ncatom!=P->natom) {
     mprintf("Warning: Number of atoms in NetCDF restart file %s (%i) does not\n",
             File->filename,ncatom);
@@ -210,7 +209,7 @@
  */
 int AmberRestartNC::setupWriteForSet(int set) {
   int dimensionID[NC_MAX_VAR_DIMS];
-  size_t start[3], count[3];
+  size_t start[2], count[2];
   char buffer[1024];
   char xyz[3];
   char abc[15] = { 'a', 'l', 'p', 'h', 'a', 
@@ -280,7 +279,7 @@
     "Defining cell angular variable.")) return 1;
 
   // Box Info
-  if (isBox>0) {
+  if (BoxType!=0) {
     dimensionID[0]=cell_spatialDID;
     if (checkNCerr(nc_def_var(ncid,"cell_lengths",NC_DOUBLE,1,dimensionID,&cellLengthVID),
       "Defining cell length variable.")) return 1;
@@ -388,9 +387,9 @@
   }
 
   // Read box info 
-  if (isBox!=0) {
-    count [0]=3;
-    count [1]=0;
+  if (BoxType!=0) {
+    count[0]=3;
+    count[1]=0;
     if ( checkNCerr(nc_get_vara_double(ncid, cellLengthVID, start, count, F->box),
                     "Getting cell lengths.")!=0 ) return 1;
     if ( checkNCerr(nc_get_vara_double(ncid, cellAngleVID, start, count, &(F->box[3])),
@@ -425,7 +424,7 @@
   }
 
   // write box
-  if (isBox>0 && cellLengthVID!=-1) {
+  if (BoxType!=0 && cellLengthVID!=-1) {
     count[0]=3;
     count[1]=0;
     if (checkNCerr(nc_put_vara_double(ncid,cellLengthVID,start,count,F->box),
@@ -439,6 +438,8 @@
   // Close file for this set
   close();
 
+  currentFrame++;
+
   return 0;
 }  
 
diff -urN amber11//AmberTools/src/cpptraj/src/AmberTraj.cpp amber11.new//AmberTools/src/cpptraj/src/AmberTraj.cpp
--- amber11//AmberTools/src/cpptraj/src/AmberTraj.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AmberTraj.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -104,16 +104,18 @@
     rprintf("Error: AmberTraj::getFrame: * detected in coordinates of %s\n",trajfilename);
     return 1;  
   } 
-  if (isBox) { 
+  if (BoxType!=0) { 
     if ( (bufferPosition = F->BufferToBox(bufferPosition,numBoxCoords,8))==NULL ) {
       rprintf("Error: AmberTraj::getFrame: * detected in box coordinates of %s\n",
               trajfilename);
       return 1;
     }
-    // Set box angles to parmtop default
-    F->box[3] = P->Box[0];
-    F->box[4] = P->Box[0];
-    F->box[5] = P->Box[0];
+    // Set box angles to parmtop default if not read in
+    if (numBoxCoords==3) {
+      F->box[3] = P->Box[3];
+      F->box[4] = P->Box[4];
+      F->box[5] = P->Box[5];
+    }
   }
   return 0;
 }
@@ -138,20 +140,22 @@
   }
 
   bufferPosition = F->FrameToBuffer(bufferPosition,"%8.3lf",8,10);
-  if (isBox) 
+  if (BoxType!=0) 
     bufferPosition = F->BoxToBuffer(bufferPosition,numBoxCoords,"%8.3lf",8);
 
   outFrameSize = (int) (bufferPosition - frameBuffer);
   
   //if (seekable) 
   // NOTE: Seek only needs to happen when traj file changes
-  offset = (off_t) set;
-  offset *= (off_t) outFrameSize;
-  offset += (off_t) titleSize;
-  File->IO->Seek( offset);
+  //offset = (off_t) currentFrame;
+  //offset *= (off_t) outFrameSize;
+  //offset += (off_t) titleSize;
+  //File->IO->Seek( offset);
 
   if (File->IO->Write(frameBuffer,sizeof(char),outFrameSize)) return 1;
 
+  currentFrame++;
+ 
   return 0;
 }
 
@@ -165,6 +169,7 @@
   int frame_lines;
   int lineSize;
   long long int file_size, frame_size;
+  double box[6]; // For checking box coordinates
 
   // Attempt to open the file. open() sets the title and titleSize
   if (open()) return 1;
@@ -219,7 +224,7 @@
 
     if (strncmp(buffer,"REMD",4)==0 || strncmp(buffer,"HREMD",5)==0) {
       // REMD header - no box coords
-      isBox=0;
+      BoxType=0;
     } else if (lineSize<80) {
       /* Line is shorter than 80 chars, indicates box coords.
        * Length of the line HAS to be a multiple of 8, and probably could be
@@ -228,21 +233,22 @@
        */
       if (debug>0) mprintf("    Box line is %i chars.\n",lineSize);
       if ( ((lineSize-1)%24)!=0 ) {
-        rprintf("Error in box coord line.\nExpect only 3 or 6 box coords.\n");
+        mprintf("Error in box coord line. Expect only 3 or 6 box coords.\n");
         return 1;
       }
       numBoxCoords=(lineSize-1) / 8;
       if (debug>0) mprintf("    Detected %i box coords.\n",numBoxCoords);
-      frameSize+=lineSize;
+      // Determine box type based on angles. Angles are usually not printed 
+      // for orthogonal and truncated octahedral boxes, but check here just
+      // to be safe. If no angles present use parmtop Box Type.
+      if (numBoxCoords>3) {
+        sscanf(buffer, "%8lf%8lf%8lf%8lf%8lf%8lf",box,box+1,box+2,box+3,box+4,box+5);
+        CheckBoxType(box);
+      } else
+        BoxType = P->BoxType; 
       // Reallocate frame buffer accordingly
+      frameSize+=lineSize;
       frameBuffer=(char*) realloc(frameBuffer,frameSize * sizeof(char));
-      if (P->ifbox==0) { 
-        rprintf( "Warning: Box coords detected in trajectory but not defined in topology!\n");
-        rprintf("         Setting box type to rectangular.\n");
-        isBox=1;
-      } else {
-        isBox = P->ifbox;
-      }
     }
   }
 
@@ -315,7 +321,9 @@
   frameSize += hasREMD;
 
   // If box coords are present, allocate extra space for them
-  if (isBox>0) {
+  // NOTE: Currently only writing box lengths for all box types. This means
+  //       writing triclinic box type is currently not supported.
+  if (BoxType!=0) {
     numBoxCoords=3; // Only write out box lengths for trajectories
     frameSize+=((numBoxCoords*8)+1);
   }
diff -urN amber11//AmberTools/src/cpptraj/src/ArgList.cpp amber11.new//AmberTools/src/cpptraj/src/ArgList.cpp
--- amber11//AmberTools/src/cpptraj/src/ArgList.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/ArgList.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -147,6 +147,16 @@
 }
 
 /*
+ * ArgList::Arg()
+ * Return arg at specified position.
+ */
+char *ArgList::Arg(int pos) {
+  if (pos>-1 && pos<nargs) 
+    return arglist[pos];
+  return NULL;
+}
+
+/*
  * ArgList::Command()
  * Check the first arg for command
  * Mark and return. Return even if marked.
diff -urN amber11//AmberTools/src/cpptraj/src/ArgList.h amber11.new//AmberTools/src/cpptraj/src/ArgList.h
--- amber11//AmberTools/src/cpptraj/src/ArgList.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/ArgList.h	2011-05-19 18:35:57.000000000 +0300
@@ -15,6 +15,7 @@
     void Add(char *);
     void print();
     char *ArgLine();
+    char *Arg(int);
 
     char *Command();
     int CommandIs(const char *);
diff -urN amber11//AmberTools/src/cpptraj/src/AtomMap.cpp amber11.new//AmberTools/src/cpptraj/src/AtomMap.cpp
--- amber11//AmberTools/src/cpptraj/src/AtomMap.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/AtomMap.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -6,6 +6,7 @@
 #include "TorsionRoutines.h"
 // DEBUG
 #include "Mol2File.h"
+#include <cstdio>
 
 //--------- PRIVATE ROUTINES ---------------------------------------
 /*
@@ -463,21 +464,27 @@
 // Write atommap out as a mol2 file, useful for checking bond info
 void atommap::WriteMol2(char *m2filename) {
   Mol2File outfile;
-  int *Selected;
+  AtomMask M1;
   // Temporary parm to play with
   AmberParm *tmpParm;
+  Frame *tmpFrame;
 
   // Create mask containing all atoms
-  Selected = (int*) malloc(natom*sizeof(int));
-  for (int atom=0; atom<natom; atom++) Selected[atom]=atom;
+  //for (int atom=0; atom<natom; atom++) Selected[atom]=atom;
   // Fake strip, just use as crap way to copy
-  tmpParm = P->modifyStateByMask(Selected,natom);
-  free(Selected);
+  //tmpParm = P->modifyStateByMask(Selected,natom);
+  //free(Selected);
   // Modify the bonds array to include this info
-  tmpParm->ResetBondInfo();
-  for (int atom=0; atom<natom; atom++) 
-    for (int bond=0; bond < M[atom].nbond; bond++) 
-      tmpParm->AddBond(atom, M[atom].bond[bond], 0);
+  //tmpParm->ResetBondInfo();
+  //for (int atom=0; atom<natom; atom++) 
+  //  for (int bond=0; bond < M[atom].nbond; bond++) 
+  //    tmpParm->AddBond(atom, M[atom].bond[bond], 0);
+  // Create mask with all mapped atoms
+  for (int atom=0; atom<natom; atom++) {if (M[atom].isMapped) M1.AddAtom(atom);}
+  // Strip so only mapped atoms remain
+  tmpParm = P->modifyStateByMask(M1.Selected,M1.Nselected);
+  tmpFrame = new Frame(M1.Nselected,NULL);
+  tmpFrame->SetFrameFromMask(F, &M1);
 
   // Trajectory Setup
   outfile.File=new PtrajFile();
@@ -485,13 +492,14 @@
   outfile.trajfilename = outfile.File->basefilename;
   outfile.debug=debug;
   outfile.SetTitle(m2filename);
-  outfile.P=P;
+  outfile.P=tmpParm;
   outfile.SetupWrite();
   outfile.open();
-  outfile.F=F;
+  outfile.F=tmpFrame;
   outfile.writeFrame(0);
   outfile.close();
   delete tmpParm;
+  delete tmpFrame;
 }
 // ============================================================================
 
@@ -1032,6 +1040,13 @@
   int iterations=0;
 
   numAtomsMapped=MapUniqueAtoms(Ref, Tgt);
+  // DEBUG
+  //char name[1024];
+  //sprintf(name,"Ref.%i.mol2",iterations);
+  //Ref->WriteMol2(name);
+  //sprintf(name,"Tgt.%i.mol2",iterations);
+  //Tgt->WriteMol2(name);
+  // END DEBUG
   if (debug>0)
     mprintf("*         MapUniqueAtoms: %i atoms mapped.\n",numAtomsMapped);
   if (numAtomsMapped==0) return 1;
@@ -1045,17 +1060,35 @@
     iterations++;
     // First assign based on bonds to unique (already mapped) atoms.
     numAtomsMapped=mapBondsToUnique(Ref,Tgt);
+    // DEBUG
+    //sprintf(name,"Ref.%i.u.mol2",iterations);
+    //Ref->WriteMol2(name);
+    //sprintf(name,"Tgt.%i.u.mol2",iterations);
+    //Tgt->WriteMol2(name);
+    // END DEBUG
     if (debug>0)
       mprintf("* [%3i] mapBondsToUnique: %i atoms mapped.\n",iterations,numAtomsMapped);
     if (numAtomsMapped<0) return 1;
     // Next assign based on chirality
     numAtomsMapped=mapChiral(Ref,Tgt);
+    // DEBUG
+    //sprintf(name,"Ref.%i.c.mol2",iterations);
+    //Ref->WriteMol2(name);
+    //sprintf(name,"Tgt.%i.c.mol2",iterations);
+    //Tgt->WriteMol2(name);
+    // END DEBUG
     if (debug>0)
       mprintf("* [%3i]        mapChiral: %i atoms mapped.\n",iterations,numAtomsMapped);
     if (numAtomsMapped<0) return 1;
     if (numAtomsMapped>0) continue;
     // Last assign based on index/element
     numAtomsMapped=mapByIndex(Ref,Tgt);
+    // DEBUG
+    //sprintf(name,"Ref.%i.i.mol2",iterations);
+    //Ref->WriteMol2(name);
+    //sprintf(name,"Tgt.%i.i.mol2",iterations);
+    //Tgt->WriteMol2(name);
+    // END DEBUG
     if (debug>0)
       mprintf("* [%3i]       mapByIndex: %i atoms mapped.\n",iterations,numAtomsMapped);
     if (numAtomsMapped<0) return 1;
diff -urN amber11//AmberTools/src/cpptraj/src/cpptrajdepend amber11.new//AmberTools/src/cpptraj/src/cpptrajdepend
--- amber11//AmberTools/src/cpptraj/src/cpptrajdepend	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/cpptrajdepend	2011-05-19 18:35:57.000000000 +0300
@@ -2,7 +2,7 @@
 AmberNetcdf.o : AmberNetcdf.cpp AmberNetcdf.h AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h Frame.h NetcdfRoutines.h PtrajFile.h Range.h TrajFile.h
 AmberParm.o : AmberParm.cpp AmberParm.h BaseFileIO.h CpptrajStdio.h Mol2FileRoutines.h PDBfileRoutines.h PtrajFile.h
 AmberTraj.o : AmberTraj.cpp AmberParm.h AmberTraj.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h Frame.h PtrajFile.h Range.h TrajFile.h
-TrajFile.o : TrajFile.cpp AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h Frame.h PtrajFile.h PtrajMpi.h Range.h TrajFile.h
+TrajFile.o : TrajFile.cpp AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h Frame.h PtrajFile.h Range.h TrajFile.h
 Frame.o : Frame.cpp AmberParm.h AtomMask.h BaseFileIO.h CpptrajStdio.h DistRoutines.h Frame.h PtrajFile.h TorsionRoutines.h vectormath.h
 PtrajState.o : PtrajState.cpp Action.h AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CoordFileList.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h ParmFileList.h PtrajActionList.h PtrajFile.h PtrajMpi.h PtrajState.h Range.h ReferenceList.h TrajFile.h TrajinList.h TrajoutList.h
 ArgList.o : ArgList.cpp ArgList.h CpptrajStdio.h
@@ -13,7 +13,7 @@
 TrajoutList.o : TrajoutList.cpp AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CoordFileList.h CpptrajStdio.h Frame.h ParmFileList.h PtrajFile.h Range.h TrajFile.h TrajoutList.h
 ReferenceList.o : ReferenceList.cpp AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CoordFileList.h CpptrajStdio.h Frame.h FrameList.h ParmFileList.h PtrajFile.h Range.h ReferenceList.h TrajFile.h
 CoordFileList.o : CoordFileList.cpp AmberNetcdf.h AmberParm.h AmberRestart.h AmberRestartNC.h AmberTraj.h ArgList.h AtomMask.h BaseFileIO.h Conflib.h CoordFileList.h CpptrajStdio.h Frame.h Mol2File.h PDBfile.h ParmFileList.h PtrajFile.h Range.h RemdTraj.h TrajFile.h TrajinList.h
-PtrajActionList.o : PtrajActionList.cpp Action.h Action_Angle.h Action_Center.h Action_Closest.h Action_DSSP.h Action_Dihedral.h Action_Distance.h Action_Hbond.h Action_Image.h Action_Mask.h Action_NAstruct.h Action_Outtraj.h Action_Pucker.h Action_Radgyr.h Action_Rmsd.h Action_Strip.h Action_Surf.h AmberParm.h ArgList.h AtomMap.h AtomMask.h AxisType.h BaseFileIO.h CoordFileList.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h ParmFileList.h PtrajActionList.h PtrajFile.h Range.h TrajFile.h TrajoutList.h
+PtrajActionList.o : PtrajActionList.cpp Action.h Action_Angle.h Action_Center.h Action_Closest.h Action_DSSP.h Action_Dihedral.h Action_Distance.h Action_Hbond.h Action_Image.h Action_Mask.h Action_NAstruct.h Action_Outtraj.h Action_Pucker.h Action_Radgyr.h Action_Rms2d.h Action_Rmsd.h Action_Strip.h Action_Surf.h AmberParm.h ArgList.h AtomMap.h AtomMask.h AxisType.h BaseFileIO.h CoordFileList.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h ParmFileList.h PtrajActionList.h PtrajFile.h Range.h TrajFile.h TrajoutList.h
 DataSet.o : DataSet.cpp CpptrajStdio.h DataSet.h
 DataSetList.o : DataSetList.cpp CpptrajStdio.h DataSet.h DataSetList.h intDataSet.h mapDataSet.h stringDataSet.h
 vectormath.o : vectormath.cpp CpptrajStdio.h vectormath.h
@@ -23,9 +23,9 @@
 DataFile.o : DataFile.cpp BaseFileIO.h CpptrajStdio.h DataFile.h DataSet.h PtrajFile.h
 DataFileList.o : DataFileList.cpp BaseFileIO.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h PtrajFile.h
 PDBfile.o : PDBfile.cpp AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h Frame.h PDBfile.h PDBfileRoutines.h PtrajFile.h Range.h TrajFile.h
-PtrajFile.o : PtrajFile.cpp BaseFileIO.h Bzip2File.h CpptrajStdio.h GzipFile.h MpiFile.h NetcdfRoutines.h PDBfileRoutines.h PtrajFile.h PtrajMpi.h StdFile.h
+PtrajFile.o : PtrajFile.cpp BaseFileIO.h Bzip2File.h CpptrajStdio.h GzipFile.h Mol2FileRoutines.h MpiFile.h NetcdfRoutines.h PDBfileRoutines.h PtrajFile.h PtrajMpi.h StdFile.h
 PDBfileRoutines.o : PDBfileRoutines.cpp PDBfileRoutines.h
-AtomMap.o : AtomMap.cpp Action.h AmberParm.h ArgList.h AtomMap.h AtomMask.h BaseFileIO.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h PDBfileRoutines.h ParmFileList.h PtrajFile.h TorsionRoutines.h
+AtomMap.o : AtomMap.cpp Action.h AmberParm.h ArgList.h AtomMap.h AtomMask.h BaseFileIO.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h Mol2File.h ParmFileList.h PtrajFile.h Range.h TorsionRoutines.h TrajFile.h
 BaseFileIO.o : BaseFileIO.cpp BaseFileIO.h PtrajMpi.h
 StdFile.o : StdFile.cpp BaseFileIO.h StdFile.h
 GzipFile.o : GzipFile.cpp BaseFileIO.h CpptrajStdio.h GzipFile.h
@@ -62,3 +62,4 @@
 Action_Pucker.o : Action_Pucker.cpp Action.h Action_Pucker.h AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h ParmFileList.h PtrajFile.h
 Range.o : Range.cpp ArgList.h CpptrajStdio.h Range.h
 Action_Outtraj.o : Action_Outtraj.cpp Action.h Action_Outtraj.h AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CoordFileList.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h ParmFileList.h PtrajFile.h PtrajMpi.h Range.h TrajFile.h TrajoutList.h
+Action_Rms2d.o : Action_Rms2d.cpp Action.h Action_Rms2d.h AmberParm.h ArgList.h AtomMask.h BaseFileIO.h CpptrajStdio.h DataFile.h DataFileList.h DataSet.h DataSetList.h Frame.h FrameList.h ParmFileList.h PtrajFile.h
diff -urN amber11//AmberTools/src/cpptraj/src/DataFile.cpp amber11.new//AmberTools/src/cpptraj/src/DataFile.cpp
--- amber11//AmberTools/src/cpptraj/src/DataFile.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/DataFile.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -66,6 +66,49 @@
 }
 
 /*
+ * DataFile::SetPrecision()
+ * Set precision of the specified dataset to width.precision. If '*' specified 
+ * set for all datasets in file.
+ */
+void DataFile::SetPrecision(char *dsetName, int widthIn, int precisionIn) {
+  int precision, dset;
+  DataSet *Dset = NULL;
+
+  if (dsetName==NULL) {
+    mprintf("Error: SetPrecision must be called with dataset name or '*'.\n");
+    return;
+  }
+  if (widthIn<1) {
+    mprintf("Error: SetPrecision (%s): Cannot set width < 1.\n",filename);
+    return;
+  }
+  precision=precisionIn;
+  if (precisionIn<0) precision=0;
+  // If <dsetName>=='*' specified set precision for all data sets
+  if (dsetName[0]=='*') {
+    mprintf("    Setting width.precision for all sets in %s to %i.%i\n",
+            filename,widthIn,precision);
+    for (dset=0; dset<Nsets; dset++)
+      SetList[dset]->SetPrecision(widthIn,precision);
+
+  // Otherwise find dataset <dsetName> and set precision
+  } else {
+    mprintf("    Setting width.precision for dataset %s to %i.%i\n",
+            dsetName,widthIn,precision);
+    for (dset=0; dset<Nsets; dset++) {
+      if ( strcmp(SetList[dset]->Name(), dsetName)==0 ) {
+        Dset=SetList[dset];
+        break;
+      }
+    }
+    if (Dset!=NULL)
+      Dset->SetPrecision(widthIn,precision);
+    else
+      mprintf("Error: Dataset %s not found in datafile %s\n",dsetName,filename);
+  }
+}
+
+/*
  * DataFile::AddSet()
  * Add given set to this datafile
  */
diff -urN amber11//AmberTools/src/cpptraj/src/DataFile.h amber11.new//AmberTools/src/cpptraj/src/DataFile.h
--- amber11//AmberTools/src/cpptraj/src/DataFile.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/DataFile.h	2011-05-19 18:35:57.000000000 +0300
@@ -30,6 +30,7 @@
     void SetXlabel(char*);
     void SetInverted();
     void SetNoXcol();
+    void SetPrecision(char *, int, int);
     int AddSet(DataSet *);
     int NameIs(char *);
     void DataSetNames();
diff -urN amber11//AmberTools/src/cpptraj/src/DataSet.cpp amber11.new//AmberTools/src/cpptraj/src/DataSet.cpp
--- amber11//AmberTools/src/cpptraj/src/DataSet.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/DataSet.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -1,6 +1,7 @@
 // DataSet
 #include <cstdlib>
 #include <cstring>
+#include <cstdio> // sprintf
 #include "DataSet.h"
 #include "CpptrajStdio.h"
 
@@ -11,12 +12,73 @@
   N=0;
   isDynamic=false;
   current=0;
+  width = 0;
+  precision = 0;
+  format = NULL;
+  dType = UNKNOWN_DATA;
 }
 
 // DESTRUCTOR
 DataSet::~DataSet() {
   //fprintf(stderr,"DataSet Destructor\n");
   if (name!=NULL) free(name);
+  if (format!=NULL) free(format);
+}
+
+/*
+ * DataSet::setFormatString()
+ * Set up the output format string for each data element based on the given 
+ * dataType and the current width, and precision.
+ */
+void DataSet::setFormatString() {
+  size_t stringWidth = 0;
+  int wWidth = 0;
+  int pWidth = 0;
+
+  if (format!=NULL) {free(format); format=NULL;}
+
+  // Calc num of chars necessary to hold width
+  wWidth = (width / 10) + 1;
+
+  switch (dType) {
+    case DOUBLE :
+      // Calc num of chars necessary to hold precision
+      pWidth = (precision / 10) + 1;
+      // String fmt: " %w.plf\0"
+      stringWidth = pWidth + wWidth + 6;
+      format = (char*) malloc( stringWidth * sizeof(char) );
+      sprintf(format, " %%%i.%ilf", width, precision);
+      break;
+    case STRING :
+      // String fmt: " %s"
+      format = (char*) malloc( 4 * sizeof(char) );
+      strcpy(format, " %s");
+      break;
+    case INT :
+      // String fmt: " %wi"
+      stringWidth = wWidth + 4;
+      format = (char*) malloc( stringWidth * sizeof(char) );
+      sprintf(format, " %%%ii", width);
+      break;
+    case UNKNOWN_DATA :
+      mprintf("Internal Error: setFormatString called with unknown data type.\n");
+  }
+
+  if (format==NULL) 
+    mprintf("Error: setFormatString: Could not allocate memory for string.\n");
+  // DEBUG
+  //else
+  //  mprintf("DEBUG: Format string: [%s]\n",format);
+}    
+
+/*
+ * DataSet::SetPrecision()
+ * Set dataset width and precision and recalc output format string.
+ */
+void DataSet::SetPrecision(int widthIn, int precisionIn) {
+  width=widthIn;
+  precision=precisionIn;
+  setFormatString();
 }
 
 /* 
diff -urN amber11//AmberTools/src/cpptraj/src/DataSet.h amber11.new//AmberTools/src/cpptraj/src/DataSet.h
--- amber11//AmberTools/src/cpptraj/src/DataSet.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/DataSet.h	2011-05-19 18:35:57.000000000 +0300
@@ -36,12 +36,18 @@
 class DataSet {
   protected:
     char *name;        // Name of the dataset
+    dataType dType;    // The dataset type
     int N;             // Number of data elements
     int current;       // The current data element
+    int width;         // The output width of a data element
+    int precision;     // The output precision of a data element (if applicable)
+    char *format;      // Format of output
+    
     bool isDynamic;    // True : N is not known, reallocate as N increases
                        // False: N is known, allocate for N
     // If not isDynamic, Allocate will reserve space for N data elements 
     virtual int Allocate( )      { return 0; }
+    void setFormatString();
 
   public:
 
@@ -51,13 +57,16 @@
     virtual int Xmax()               { return 0; }
     virtual int isEmpty(int)         { return 0; }
     virtual void Add( int, void * )  { return;   }
+    virtual int Get( void *, int )   { return 1; }
     virtual char *Write(char*, int)  { return 0; }
     virtual int Width()              { return 0; }
     virtual int Sync()               { return 0; }
 
+    void SetPrecision(int,int);
     int Setup(char*,int);
     void Info();
     char *Name() { return name; }
     int CheckSet();
+    dataType Type() {return dType;}
 };
 #endif 
diff -urN amber11//AmberTools/src/cpptraj/src/Frame.cpp amber11.new//AmberTools/src/cpptraj/src/Frame.cpp
--- amber11//AmberTools/src/cpptraj/src/Frame.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Frame.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -61,6 +61,40 @@
 }
 
 /*
+ * Frame::ZeroCoords()
+ * Set all coords to 0.0
+ */
+void Frame::ZeroCoords() {
+  for (int coord=0; coord < N; coord++)
+    X[coord]=0.0;
+}
+
+/*
+ * Frame::AddCoord()
+ * Add the coord values from the input frame to the coord values of 
+ * this frame.
+ */
+void Frame::AddCoord(Frame *FrameIn) {
+  if (FrameIn->N != this->N) {
+    mprintf("Error: Frame::AddCoord: Attempting to add %i coords to %i coords.\n",
+            FrameIn->N,this->N);
+  } else {
+    for (int coord=0; coord < N; coord++)
+      this->X[coord] += FrameIn->X[coord];
+  }
+}
+
+/* 
+ * Frame::Divide()
+ * Divide all coord values by input. Dont do it if the number is too small.
+ */
+void Frame::Divide(double divisor) {
+  if (divisor < SMALL) return;
+  for (int coord=0; coord < N; coord++)
+    X[coord] /= divisor;
+}
+
+/*
  * Frame::Copy()
  * Return a copy of the frame
  */
@@ -423,21 +457,21 @@
  * Based on useMassIn, calculate geometric center (false) or center of mass 
  * (true) of the atoms in each mask.
  */
-double Frame::DIST2(AtomMask *Mask1, AtomMask *Mask2, bool useMassIn, int ifbox,
+double Frame::DIST2(AtomMask *Mask1, AtomMask *Mask2, bool useMassIn, int boxType,
                     double *ucell, double *recip) {
   double a1[3], a2[3];
 
   COM(Mask1, a1, useMassIn);
   COM(Mask2, a2, useMassIn);
 
-  if (ifbox == 0) 
+  if (boxType == 0) 
     return DIST2_NoImage(a1, a2);
-  else if (ifbox == 1) 
+  else if (boxType == 1) 
     return DIST2_ImageOrtho(a1, a2, this->box);
-  else if (ifbox == 2) 
+  else if (boxType == 2) 
     return DIST2_ImageNonOrtho(a1, a2, ucell, recip);
 
-  mprintf("    Error: Frame::DIST: Unrecognized box type (%i)\n.", ifbox);
+  mprintf("    Error: Frame::DIST: Unrecognized box type (%i)\n.", boxType);
 
   return (-1.0);
 }
@@ -445,8 +479,11 @@
 /*
  * Frame::DIST2()
  * Return the distance between atoms A1 and A2 with optional imaging.
+ *   0 = None
+ *   1 = Orthorhombic
+ *   2 = Non-orthorhombic
  */
-double Frame::DIST2(int A1, int A2, int ifbox, double *ucell, double *recip) {
+double Frame::DIST2(int A1, int A2, int boxType, double *ucell, double *recip) {
   int atom3;
   double a1[3], a2[3];
 
@@ -459,14 +496,14 @@
   a2[1] = X[atom3+1];
   a2[2] = X[atom3+2];
 
-  if (ifbox == 0)
+  if (boxType == 0)
     return DIST2_NoImage(a1, a2);
-  else if (ifbox == 1)
+  else if (boxType == 1)
     return DIST2_ImageOrtho(a1, a2, this->box);
-  else if (ifbox == 2) 
+  else if (boxType == 2) 
     return DIST2_ImageNonOrtho(a1, a2, ucell, recip);
 
-  mprintf("    Error: Frame::DIST: Unrecognized box type (%i)\n.", ifbox);
+  mprintf("    Error: Frame::DIST: Unrecognized box type (%i)\n.", boxType);
 
   return (-1.0);
 }
diff -urN amber11//AmberTools/src/cpptraj/src/Frame.h amber11.new//AmberTools/src/cpptraj/src/Frame.h
--- amber11//AmberTools/src/cpptraj/src/Frame.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Frame.h	2011-05-19 18:35:57.000000000 +0300
@@ -22,6 +22,9 @@
     Frame(AtomMask *, double *);
     virtual ~Frame();             // Destructor is virtual since this class can be inherited
 
+    void ZeroCoords();
+    void AddCoord(Frame*);
+    void Divide(double);
     void printAtomCoord(int);
     void GetCoord(double *, int);
     void SetCoord(int, double *);
diff -urN amber11//AmberTools/src/cpptraj/src/FrameList.cpp amber11.new//AmberTools/src/cpptraj/src/FrameList.cpp
--- amber11//AmberTools/src/cpptraj/src/FrameList.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/FrameList.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -13,7 +13,8 @@
     delete frameList[i];
 }
 
-/* FrameList::Add()
+/* 
+ * FrameList::Add()
  * Add given Frame to the FrameList. Store trajectory name that this frame
  * came from in frameNames. Store the associated parm in FrameParm. 
  */
@@ -29,6 +30,18 @@
   FrameParm.Add(P);
   Nframe++;
   return 0;
+}
+
+/*
+ * FrameList::Add()
+ * Add given Frame to the FrameList. Store the associated parm in FrameParm.
+ */
+int FrameList::Add(Frame *F, AmberParm *P) {
+  if (F==NULL || P==NULL) return 1;
+  frameList.push_back(F);
+  FrameParm.Add(P);
+  Nframe++;
+  return 0;
 }
 
 /* 
diff -urN amber11//AmberTools/src/cpptraj/src/FrameList.h amber11.new//AmberTools/src/cpptraj/src/FrameList.h
--- amber11//AmberTools/src/cpptraj/src/FrameList.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/FrameList.h	2011-05-19 18:35:57.000000000 +0300
@@ -18,6 +18,7 @@
     ~FrameList();
 
     int Add(Frame *, char *, AmberParm *,int);
+    int Add(Frame *, AmberParm *);
     AmberParm *GetFrameParm(int);
     int GetFrameIndex(char *);
     Frame *GetFrame(int idx);
diff -urN amber11//AmberTools/src/cpptraj/src/intDataSet.cpp amber11.new//AmberTools/src/cpptraj/src/intDataSet.cpp
--- amber11//AmberTools/src/cpptraj/src/intDataSet.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/intDataSet.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -5,6 +5,14 @@
 #include "PtrajMpi.h"
 #include "CpptrajStdio.h"
 using namespace std;
+
+// CONSTRUCTOR
+intDataSet::intDataSet() {
+  width=12;
+  dType=INT;
+  setFormatString();
+}
+
 /*
  * intDataSet::Xmax(()
  * Return the maximum X value added to this set. By convention this is 
@@ -34,6 +42,21 @@
 }
 
 /*
+ * intDataSet::Get()
+ * Get data at frame, put into vOut. Return 1 if no data at frame.
+ */
+int intDataSet::Get(void *vOut, int frame) {
+  int *value;
+
+  if (vOut==NULL) return 1;
+  value = (int*) vOut;
+  it=Data.find( frame );
+  if (it == Data.end()) return 1;
+  *value = (*it).second;
+  return 0;
+}
+
+/*
  * intDataSet::isEmpty()
  */
 int intDataSet::isEmpty(int frame) {
@@ -52,17 +75,17 @@
   it = Data.find( frame );
   if (it == Data.end()) 
     //sprintf(buffer," %12s","NoData");
-    sprintf(buffer," %12i", 0);
+    sprintf(buffer, format, 0);
   else 
-    sprintf(buffer," %12i",(*it).second);
-  return (buffer + 13);
+    sprintf(buffer, format, (*it).second);
+  return (buffer + width + 1);
 }
 
 /*
  * intDataSet::Width()
  */
 int intDataSet::Width() {
-  return 13;
+  return (width + 1);
 }
 
 /*
diff -urN amber11//AmberTools/src/cpptraj/src/intDataSet.h amber11.new//AmberTools/src/cpptraj/src/intDataSet.h
--- amber11//AmberTools/src/cpptraj/src/intDataSet.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/intDataSet.h	2011-05-19 18:35:57.000000000 +0300
@@ -11,9 +11,12 @@
     std::map<int,int> Data;
     std::map<int,int>::iterator it;
   public:
+    intDataSet();
+
     int Xmax();
     int isEmpty(int);
     void Add( int, void * );
+    int Get(void *, int);
     char *Write(char *, int);
     int Width();
     int Sync();
diff -urN amber11//AmberTools/src/cpptraj/src/main.cpp amber11.new//AmberTools/src/cpptraj/src/main.cpp
--- amber11//AmberTools/src/cpptraj/src/main.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/main.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -6,7 +6,7 @@
 #include "PtrajMpi.h"
 #include "CpptrajStdio.h"
 #ifndef CPPTRAJ_VERSION_STRING
-#define CPPTRAJ_VERSION_STRING "V1.0.5"
+#define CPPTRAJ_VERSION_STRING "V1.0.8"
 #endif
 
 void Usage(char *programName) {
diff -urN amber11//AmberTools/src/cpptraj/src/Makefile amber11.new//AmberTools/src/cpptraj/src/Makefile
--- amber11//AmberTools/src/cpptraj/src/Makefile	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Makefile	2011-05-19 18:35:57.000000000 +0300
@@ -16,7 +16,8 @@
        Action_Radgyr.cpp Conflib.cpp Action_Mask.cpp Action_Closest.cpp \
        NetcdfRoutines.cpp AmberRestartNC.cpp CpptrajStdio.cpp Mol2File.cpp \
        Mol2FileRoutines.cpp Action_NAstruct.cpp DistRoutines.cpp AxisType.cpp \
-       TorsionRoutines.cpp Action_Pucker.cpp Range.cpp Action_Outtraj.cpp
+       TorsionRoutines.cpp Action_Pucker.cpp Range.cpp Action_Outtraj.cpp \
+       Action_Rms2d.cpp
 
 OBJECTS=main.o AmberNetcdf.o AmberParm.o AmberTraj.o TrajFile.o \
         Frame.o PtrajState.o ArgList.o ptrajmask.o Action_Distance.o \
@@ -32,7 +33,8 @@
         Action_Radgyr.o Conflib.o Action_Mask.o Action_Closest.o \
         NetcdfRoutines.o AmberRestartNC.o CpptrajStdio.o Mol2File.o \
         Mol2FileRoutines.o Action_NAstruct.o DistRoutines.o AxisType.o \
-        TorsionRoutines.o Action_Pucker.o Range.o Action_Outtraj.o
+        TorsionRoutines.o Action_Pucker.o Range.o Action_Outtraj.o \
+        Action_Rms2d.o
 
 HEADERS=AmberNetcdf.h AmberParm.h AmberTraj.h TrajFile.h \
         Frame.h PtrajState.h ArgList.h ptrajmask.h Action.h Action_Distance.h \
@@ -48,7 +50,8 @@
         Action_Radgyr.h Conflib.h Action_Mask.h Action_Closest.h \
         NetcdfRoutines.h AmberRestartNC.h CpptrajStdio.h Mol2File.h \
         Mol2FileRoutines.h Action_NAstruct.h DistRoutines.h AxisType.h \
-        TorsionRoutines.h Action_Pucker.h Range.h Action_Outtraj.h
+        TorsionRoutines.h Action_Pucker.h Range.h Action_Outtraj.h \
+        Action_Rms2d.h
 
 all: cpptraj$(SFX)
 
diff -urN amber11//AmberTools/src/cpptraj/src/Makefile_at amber11.new//AmberTools/src/cpptraj/src/Makefile_at
--- amber11//AmberTools/src/cpptraj/src/Makefile_at	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Makefile_at	2011-05-19 18:35:57.000000000 +0300
@@ -16,7 +16,8 @@
        Action_Radgyr.cpp Conflib.cpp Action_Mask.cpp Action_Closest.cpp \
        NetcdfRoutines.cpp AmberRestartNC.cpp CpptrajStdio.cpp Mol2File.cpp \
        Mol2FileRoutines.cpp Action_NAstruct.cpp DistRoutines.cpp AxisType.cpp \
-       TorsionRoutines.cpp Action_Pucker.cpp Range.cpp Action_Outtraj.cpp
+       TorsionRoutines.cpp Action_Pucker.cpp Range.cpp Action_Outtraj.cpp \
+       Action_Rms2d.cpp
 
 OBJECTS=main.o AmberNetcdf.o AmberParm.o AmberTraj.o TrajFile.o \
         Frame.o PtrajState.o ArgList.o ptrajmask.o Action_Distance.o \
@@ -32,7 +33,8 @@
         Action_Radgyr.o Conflib.o Action_Mask.o Action_Closest.o \
         NetcdfRoutines.o AmberRestartNC.o CpptrajStdio.o Mol2File.o \
         Mol2FileRoutines.o Action_NAstruct.o DistRoutines.o AxisType.o \
-        TorsionRoutines.o Action_Pucker.o Range.o Action_Outtraj.o
+        TorsionRoutines.o Action_Pucker.o Range.o Action_Outtraj.o \
+        Action_Rms2d.o
 
 HEADERS=AmberNetcdf.h AmberParm.h AmberTraj.h TrajFile.h \
         Frame.h PtrajState.h ArgList.h ptrajmask.h Action.h Action_Distance.h \
@@ -48,7 +50,8 @@
         Action_Radgyr.h Conflib.h Action_Mask.h Action_Closest.h \
         NetcdfRoutines.h AmberRestartNC.h CpptrajStdio.h Mol2File.h \
         Mol2FileRoutines.h Action_NAstruct.h DistRoutines.h AxisType.h \
-        TorsionRoutines.h Action_Pucker.h Range.h Action_Outtraj.h
+        TorsionRoutines.h Action_Pucker.h Range.h Action_Outtraj.h \
+        Action_Rms2d.h
 
 all: cpptraj$(SFX)
 
diff -urN amber11//AmberTools/src/cpptraj/src/mapDataSet.cpp amber11.new//AmberTools/src/cpptraj/src/mapDataSet.cpp
--- amber11//AmberTools/src/cpptraj/src/mapDataSet.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/mapDataSet.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -6,6 +6,14 @@
 #include "CpptrajStdio.h"
 using namespace std;
 
+// CONSTRUCTOR
+mapDataSet::mapDataSet() {
+  width = 12;
+  precision = 4;
+  dType=DOUBLE;
+  setFormatString();
+}
+
 /*
  * mapDataSet::Xmax(()
  * Return the maximum X value added to this set. By convention this is 
@@ -35,6 +43,23 @@
 }
 
 /*
+ * mapDataSet::Get()
+ * Get data at frame, put into vOut. Return 1 if no data at frame.
+ */
+int mapDataSet::Get(void *vOut, int frame) {
+  double *value;
+  
+  if (vOut==NULL) return 1;
+  //mprintf("DEBUG: Attempting to get double frame %i\n",frame);
+  value = (double*) vOut;
+  it=Data.find( frame );
+  if (it == Data.end()) return 1;
+  //mprintf("DEBUG: Double frame %i is %lf\n",frame,(*it).second);
+  *value = (*it).second;
+  return 0;
+}
+
+/*
  * mapDataSet::isEmpty()
  */
 int mapDataSet::isEmpty(int frame) {
@@ -53,17 +78,17 @@
   it = Data.find( frame );
   if (it == Data.end()) 
     //sprintf(buffer," %12s","NoData");
-    sprintf(buffer," %12.4lf", 0.0);
+    sprintf(buffer, format, 0.0);
   else 
-    sprintf(buffer," %12.4lf",(*it).second);
-  return (buffer + 13);
+    sprintf(buffer, format,(*it).second);
+  return (buffer + width + 1);
 }
 
 /*
  * mapDataSet::Width()
  */
 int mapDataSet::Width() {
-  return 13;
+  return (width + 1);
 }
 
 /*
diff -urN amber11//AmberTools/src/cpptraj/src/mapDataSet.h amber11.new//AmberTools/src/cpptraj/src/mapDataSet.h
--- amber11//AmberTools/src/cpptraj/src/mapDataSet.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/mapDataSet.h	2011-05-19 18:35:57.000000000 +0300
@@ -7,14 +7,16 @@
  */
 #include <map>
 #include "DataSet.h"
-//using namespace std;
 class mapDataSet : public DataSet {
     std::map<int,double> Data;
     std::map<int,double>::iterator it;
   public:
+    mapDataSet();
+
     int Xmax();
     int isEmpty(int);
     void Add( int, void * );
+    int Get(void *, int);
     char *Write(char *, int);
     int Width();
     int Sync();
diff -urN amber11//AmberTools/src/cpptraj/src/Mol2File.cpp amber11.new//AmberTools/src/cpptraj/src/Mol2File.cpp
--- amber11//AmberTools/src/cpptraj/src/Mol2File.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/Mol2File.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -239,6 +239,8 @@
   if (writeMode==2)
     File->IO->Close();
 
+  currentFrame++;
+
   return 0;
 }
  
diff -urN amber11//AmberTools/src/cpptraj/src/PDBfile.cpp amber11.new//AmberTools/src/cpptraj/src/PDBfile.cpp
--- amber11//AmberTools/src/cpptraj/src/PDBfile.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/PDBfile.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -207,6 +207,9 @@
   } else if (writeMode==1) {
     File->IO->Printf("ENDMDL\n");
   }
+
+  currentFrame++;
+
   return 0;
 }
 
diff -urN amber11//AmberTools/src/cpptraj/src/PtrajActionList.cpp amber11.new//AmberTools/src/cpptraj/src/PtrajActionList.cpp
--- amber11//AmberTools/src/cpptraj/src/PtrajActionList.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/PtrajActionList.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -20,6 +20,7 @@
 #include "Action_NAstruct.h"
 #include "Action_Pucker.h"
 #include "Action_Outtraj.h"
+#include "Action_Rms2d.h"
 
 // Constructor
 PtrajActionList::PtrajActionList() {
@@ -56,6 +57,7 @@
 
   // Decide what action this is based on the command.
   if      (A->CommandIs("distance")) {Act=new Distance;}
+  else if (A->CommandIs("rms2d"))    {Act=new Rms2d;   }
   else if (A->CommandIs("rmsd",3))   {Act=new Rmsd;    }
   else if (A->CommandIs("dihedral")) {Act=new Dihedral;}
   else if (A->CommandIs("atommap"))  {Act=new AtomMap; }
@@ -166,6 +168,8 @@
     err = ActionList[act]->DoAction(FrameAddress, frameIn);
     if (err==1) {
       // Treat actions that fail as if they could not be set up
+      mprintf("Warning: Action [%s] failed, frame %i.\n",ActionList[act]->CmdLine(),
+              frameIn);
       ActionList[act]->noSetup=1;
     } else if (err==2) {
       // Return value of 2 requests return to original frame
diff -urN amber11//AmberTools/src/cpptraj/src/PtrajFile.cpp amber11.new//AmberTools/src/cpptraj/src/PtrajFile.cpp
--- amber11//AmberTools/src/cpptraj/src/PtrajFile.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/PtrajFile.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -113,6 +113,7 @@
 void PtrajFile::CloseFile() {
   if (isOpen) {
     IO->Close();
+    if (debug>0) rprintf("Closed %s.\n",filename);
     isOpen=0;
   }
 }
diff -urN amber11//AmberTools/src/cpptraj/src/PtrajMpi.c amber11.new//AmberTools/src/cpptraj/src/PtrajMpi.c
--- amber11//AmberTools/src/cpptraj/src/PtrajMpi.c	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/PtrajMpi.c	2011-05-19 18:35:57.000000000 +0300
@@ -460,7 +460,10 @@
   }
 
   err = MPI_Allreduce(input, Return, count, currentType, currentOp, MPI_COMM_WORLD);
-  if (err!=MPI_SUCCESS) printMPIerr(err, "Performing allreduce for %i elements\n",count);
+  if (err!=MPI_SUCCESS) {
+    printMPIerr(err, "Performing allreduce.\n");
+    rprintf("Error: allreduce failed for %i elements.\n",count);
+  }
 
   if (parallel_check_error(err)!=0) return 1;
   return 0;
diff -urN amber11//AmberTools/src/cpptraj/src/PtrajState.cpp amber11.new//AmberTools/src/cpptraj/src/PtrajState.cpp
--- amber11//AmberTools/src/cpptraj/src/PtrajState.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/PtrajState.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -7,7 +7,8 @@
 #include "CpptrajStdio.h"
 
 // Constructor
-PtrajState::PtrajState() { 
+PtrajState::PtrajState() {
+  TotalErrors=0; 
   debug=0;
   showProgress=1;
 }
@@ -291,6 +292,7 @@
   char *df_cmd = NULL;
   char *name1 = NULL;
   char *name2 = NULL;
+  int width,precision;
   DataFile *df;
 
   if (DF_Args.empty()) return;
@@ -349,6 +351,19 @@
       }
       mprintf("    Not printing x column for datafile %s\n",name1);
       df->SetNoXcol();
+    
+    // datafile precision
+    // Usage: datafile precision <filename> <dataset> [<width>] [<precision>]
+    //        If width/precision not specified default to 12.4
+    } else if ( strcmp(df_cmd,"precision")==0 ) {
+      if (df==NULL) {
+        mprintf("Error: datafile precision: DataFile %s does not exist.\n",name1);
+        continue;
+      }
+      name2 = A->getNextString();
+      width = A->getNextInteger(12);
+      precision = A->getNextInteger(4);
+      df->SetPrecision(name2,width,precision);
     }
 
   } // END loop over datafile args
@@ -374,7 +389,7 @@
 
   // ========== S E T U P   P H A S E ========== 
   // Calculate frame division among trajectories
-  maxFrames=trajFileList.SetupFrames();
+  maxFrames=trajFileList.SetupFrames(worldrank,worldsize);
 
   // Parameter file information
   parmFileList.Print();
diff -urN amber11//AmberTools/src/cpptraj/src/PtrajState.h amber11.new//AmberTools/src/cpptraj/src/PtrajState.h
--- amber11//AmberTools/src/cpptraj/src/PtrajState.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/PtrajState.h	2011-05-19 18:35:57.000000000 +0300
@@ -20,6 +20,7 @@
     DataFileList DFL;                // List of datafiles that data sets will be written to
     ArgList *A;                      // Current argument list
     std::list<ArgList*> DF_Args;     // List of commands pertaining to datafile creation etc
+    int TotalErrors;                 // Sum of all returned error statuses
     int debug;
 
     void SetGlobalDebug(int);        // Set debug level for all components
diff -urN amber11//AmberTools/src/cpptraj/src/ReferenceList.cpp amber11.new//AmberTools/src/cpptraj/src/ReferenceList.cpp
--- amber11//AmberTools/src/cpptraj/src/ReferenceList.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/ReferenceList.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -20,11 +20,15 @@
  */
 int ReferenceList::Add(ArgList *A, ParmFileList *parmFileList, int worldsize) {
   TrajFile *T;
-  int startArg;
+  int startArg,stopArg,offsetArg;
+  bool average = false;
 
   // Set up common arguments from arglist
   if (this->ProcessArgList(A,parmFileList)) return 1;
 
+  // Check if we want to obtain the average structure
+  average = A->hasKey("average");
+
   // Set up basic file to determine type and format
   T = this->SetupTrajectory(trajfilename, fileAccess, UNKNOWN_FORMAT, UNKNOWN_TYPE);
 
@@ -45,10 +49,18 @@
   // Get user-specified start arg
   // NOTE: For compatibility with ptraj start from 1
   startArg=A->getNextInteger(1);
-  T->SetArgs(startArg,startArg,1);
+  stopArg=startArg;
+  offsetArg=1;
+  // Get user-specified stop and offset only if getting avg structure
+  if (average) {
+    stopArg=A->getNextInteger(-1);
+    offsetArg=A->getNextInteger(1);
+  }
+  T->SetArgs(startArg,stopArg,offsetArg);
 
   // Add to trajectory file list
-  this->push_back(T); 
+  this->push_back(T);
+  Average.push_back(average); 
 
   return 0;
 }
@@ -60,9 +72,11 @@
  * place that frame in refFrames.
  */
 int ReferenceList::SetupRefFrames(FrameList *refFrames) {
-  int trajFrames;
-  Frame *F;
+  int trajFrames, global_set;
+  double Nframes;
+  Frame *F, *AvgFrame;
   int skipValue;
+  int refTrajNum = 0;
 
   mprintf("\nREFERENCE COORDS:\n");
   if (this->empty()) {
@@ -72,7 +86,13 @@
 
   for (it = this->begin(); it != this->end(); it++) {
     // Setup the reference traj for reading. Should only be 1 frame.
-    trajFrames=(*it)->setupFrameInfo(-1);
+    // NOTE: For MPI, calling setupFrameInfo with worldrank 0, worldsize 1 for 
+    //       all ranks. This is to ensure each thread has a copy of the ref 
+    //       struct.
+    //       Calling setupFrameInfo with -1 to ensure the Parm frame count is
+    //       not updated.
+
+    trajFrames=(*it)->setupFrameInfo(-1,0,1);
     if ((*it)->total_read_frames<1) {
       rprintf("Error: No frames could be read for reference %s, skipping\n",
       (*it)->trajfilename);
@@ -89,12 +109,34 @@
       skipValue=(*it)->skip;
       (*it)->skip=0;
     }
-    (*it)->Begin(&trajFrames, 0);
-    // Get and copy the 1 frame from Traj, then close
-    // NOTE: What happens when not seekable?
+    // Start trajectory read
+    global_set=0;
+    (*it)->Begin(&global_set, 0);
     (*it)->PrintInfo(1);
-    (*it)->NextFrame(&trajFrames);
-    F=(*it)->F->Copy();
+    // If averaging requested, loop over specified frames and avg coords.
+    if (Average[refTrajNum++]) {
+      mprintf("    Averaging over %i frames.\n",trajFrames);
+      AvgFrame = new Frame((*it)->P->natom, (*it)->P->mass);
+      AvgFrame->ZeroCoords();
+      global_set = 0;
+      Nframes = 0.0;
+      while ( (*it)->NextFrame(&global_set) ) {
+        AvgFrame->AddCoord( (*it)->F );
+        Nframes++;
+      }
+      if (Nframes < 1.0) { 
+        mprintf("Error: reference average: # frames read is less than 1.\n");
+        F=NULL;
+      } else {
+        AvgFrame->Divide( Nframes );
+        F=AvgFrame->Copy();
+      }
+      delete AvgFrame; 
+    // If no averaging, get and copy the 1 frame from Traj, then close
+    } else {
+      (*it)->NextFrame(&trajFrames);
+      F=(*it)->F->Copy();
+    }
     // DEBUG
     //fprintf(stdout,"DEBUG: Ref Coord Atom 0\n");
     //F->printAtomCoord(0);
diff -urN amber11//AmberTools/src/cpptraj/src/ReferenceList.h amber11.new//AmberTools/src/cpptraj/src/ReferenceList.h
--- amber11//AmberTools/src/cpptraj/src/ReferenceList.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/ReferenceList.h	2011-05-19 18:35:57.000000000 +0300
@@ -5,7 +5,7 @@
 #include "FrameList.h"
 
 class ReferenceList : public CoordFileList {
-
+    std::vector<bool> Average;
   public:
     
     ReferenceList();
diff -urN amber11//AmberTools/src/cpptraj/src/RemdTraj.cpp amber11.new//AmberTools/src/cpptraj/src/RemdTraj.cpp
--- amber11//AmberTools/src/cpptraj/src/RemdTraj.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/RemdTraj.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -88,7 +88,7 @@
   // NOTE: Should check that this is the case for ALL frames.
   stop = T->Frames;
   Frames = T->Frames;
-  isBox = T->isBox;
+  BoxType = T->BoxType;
   trajfilename = T->File->basefilename;
   // Add it to the list
   REMDtraj.push_back(T);
@@ -190,12 +190,12 @@
       return 1;
     }
     // Check that #Frames and box info matches
-    if ( Frames!=T->Frames || isBox!=T->isBox ) {
+    if ( Frames!=T->Frames || BoxType!=T->BoxType ) {
       mprintf(
-              "    ERROR: REMDTRAJ: #Frames (%i) or box info (%i) in replica does not match\n",
-              T->Frames, T->isBox);
-      mprintf("                     values in lowest replica (Frames=%i, box=%i)\n",
-              Frames,isBox);
+              "    ERROR: REMDTRAJ: #Frames (%i) or box type (%i) in replica does not match\n",
+              T->Frames, T->BoxType);
+      mprintf("                     values in lowest replica (Frames=%i, boxtype=%i)\n",
+              Frames,BoxType);
       delete T;
       free(repFilename);
       free(Prefix);
diff -urN amber11//AmberTools/src/cpptraj/src/stringDataSet.cpp amber11.new//AmberTools/src/cpptraj/src/stringDataSet.cpp
--- amber11//AmberTools/src/cpptraj/src/stringDataSet.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/stringDataSet.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -6,6 +6,13 @@
 #include "PtrajMpi.h"
 #include "CpptrajStdio.h"
 using namespace std;
+
+// CONSTRUCTOR
+stringDataSet::stringDataSet() {
+  dType=STRING;
+  setFormatString();
+}
+
 /*
  * stringDataSet::Xmax(()
  * Return the maximum X value added to this set. By convention this is 
@@ -54,10 +61,10 @@
 
   it = Data.find( frame );
   if (it == Data.end()) { 
-    sprintf(buffer," %s", "NoData");
+    sprintf(buffer, format, "NoData");
     return (buffer + 7);
   } else 
-    sprintf(buffer," %s",(*it).second.c_str());
+    sprintf(buffer, format, (*it).second.c_str());
 
   return (buffer + (*it).second.size() + 1);
 }
diff -urN amber11//AmberTools/src/cpptraj/src/stringDataSet.h amber11.new//AmberTools/src/cpptraj/src/stringDataSet.h
--- amber11//AmberTools/src/cpptraj/src/stringDataSet.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/stringDataSet.h	2011-05-19 18:35:57.000000000 +0300
@@ -12,6 +12,8 @@
     std::map<int,std::string> Data;
     std::map<int,std::string>::iterator it;
   public:
+    stringDataSet();
+
     int Xmax();
     int isEmpty(int);
     void Add( int, void * );
diff -urN amber11//AmberTools/src/cpptraj/src/TrajFile.cpp amber11.new//AmberTools/src/cpptraj/src/TrajFile.cpp
--- amber11//AmberTools/src/cpptraj/src/TrajFile.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/TrajFile.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -2,7 +2,6 @@
 #include <cstdlib>
 #include <cstring>
 #include "TrajFile.h"
-#include "PtrajMpi.h" // worldrank and worldsize needed to calc frame division
 #include "CpptrajStdio.h"
 
 // CONSTRUCTOR
@@ -18,7 +17,7 @@
   start=0;
   stop=-1;
   offset=1;
-  isBox=0;
+  BoxType=0;
   title=NULL;
   P=NULL;
   frameskip=0;
@@ -45,12 +44,17 @@
 void TrajFile::SetTitle(char *titleIn) {
   size_t titleSize;
 
+  //mprintf("DEBUG: Attempting to set title for %s: [%s]\n",trajfilename,titleIn);
   if (titleIn==NULL) return;
   titleSize = strlen(titleIn);
-  if (titleSize==0) return;
+  //mprintf("       Title size is %i\n",titleSize);
+  if (titleSize==0) {
+    mprintf("Warning: TrajFile::SetTitle(): Title for %s is 0 length.\n",trajfilename);
+    return;
+  }
   this->title = (char*) malloc( (titleSize+1) * sizeof(char));
   if (this->title==NULL) {
-    mprintf("Error: TrajFile::SetTitle(): Could not allocate memory for title.\n");
+    mprintf("Error: SetTitle: Could not allocate memory for title of %s.\n",trajfilename);
     return;
   }
   strcpy(this->title, titleIn);
@@ -59,6 +63,30 @@
 }
 
 /*
+ * TrajFile::CheckBoxType()
+ * Set the trajectory box type (ortho/nonortho) based on box angles.
+ * Check the current box type against the associated parmfile box type.
+ * Print a warning if they are different.
+ */
+void TrajFile::CheckBoxType(double *box) {
+  // Determine orthogonal / non-orthogonal from angles
+  if (box[3]==0.0 || box[4]==0.0 || box[5]==0.0)
+    BoxType=0;
+  else if (box[3]==90.0 && box[4]==90.0 && box[5]==90.0)
+    BoxType=1;
+  else
+    BoxType=2;
+  if (P->BoxType != BoxType) {
+    mprintf("Warning: %s contains box info of type %i (beta %lf)\n",trajfilename,
+            BoxType,box[4]);
+    mprintf("         but associated parmfile %s has box type %i (beta %lf)\n",P->parmName, 
+            P->BoxType,P->Box[4]);
+    //mprintf("         Box information from trajectory will be used.\n");
+  }
+  if (debug>0) mprintf("    %s: Box type is %i (beta=%lf)\n",trajfilename,BoxType,box[4]);
+}
+
+/*
  * TrajFile::PrintInfo()
  * Print general trajectory information. Call TrajFile->Info for specific information.
  */
@@ -68,7 +96,7 @@
 
   mprintf(", Parm %i",P->pindex);
 
-  if (isBox) mprintf(" (with box info)");
+  if (BoxType>0) mprintf(" (with box info)");
 
   if (showExtended==0) {
     mprintf("\n");
@@ -85,7 +113,7 @@
     mprintf(": Writing %i frames", P->parmFrames);
     if (File->access==APPEND) mprintf(", appended"); // NOTE: Dangerous if REMD
   }
-  if (debug>0) mprintf(", %i atoms, Box %i, seekable %i",P->natom,isBox,seekable);
+  if (debug>0) mprintf(", %i atoms, Box %i, seekable %i",P->natom,BoxType,seekable);
   mprintf("\n");
 }
 
@@ -164,7 +192,7 @@
  * Note that the input frames start counting from 1, output starts counting from 0!
  * If called with maxFrames=-1 dont update the frame in parm file.
  */
-int TrajFile::setupFrameInfo(int maxFrames) {
+int TrajFile::setupFrameInfo(int maxFrames, int worldrank, int worldsize) {
   int Nframes;
   int ptraj_start_frame, ptraj_end_frame;
   int traj_start_frame, traj_end_frame;
diff -urN amber11//AmberTools/src/cpptraj/src/TrajFile.h amber11.new//AmberTools/src/cpptraj/src/TrajFile.h
--- amber11//AmberTools/src/cpptraj/src/TrajFile.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/TrajFile.h	2011-05-19 18:35:57.000000000 +0300
@@ -25,44 +25,44 @@
     int offset;         // Number of frames to skip while processing
 
     // --== Inherited by child classes ==--
-    virtual int open() { return 0; }        // Open the file, prepare for coord read/write
-    virtual void close() {}                 // Close the file
+    virtual int open() { return 0; } // Open the file, prepare for coord read/write
+    virtual void close() {}          // Close the file
+
+    void CheckBoxType(double *);     // Check that traj boxtype matches parm
 
   public:
     int debug;             // Level of debug information to print
     char *trajfilename;    // The base trajectory filename
-    // NOTE: I hate that the following are public. Only necessary for REMD processing!!
+    // NOTE: I hate that the 2 following are public. Only necessary for REMD processing!!
     int Frames;            // Total number of frames in trajectory
     int total_read_frames; // Total number of frames that will be read
-    int isBox;             // >0 means trajectory has box information
-
+    int BoxType;           // 0: None, 1: Ortho, 2: NonOrtho 
     Range *FrameRange;     // list of frames to be written out
     int hasTemperature;    // 1 means trajectory has temperature information
     PtrajFile *File;       // Class that handles basic file IO
     AmberParm *P;          // Memory address of the associated parmfile
     Frame *F;              // Hold coordinates of the current frame
-    int skip;              /* READ: If =1 do not process this input trajectory 
-                              WRITE: If =1 this traj has been set up for write */
+    int skip;              // READ: If =1 do not process this input trajectory 
+                           // WRITE: If =1 this traj has been set up for write
 
     TrajFile();            // Constructor
     virtual ~TrajFile();   // Destructor - virtual since this class is inherited.
 
-    int Start() { return start; }
+    int Start()        { return start;        }
+    int CurrentFrame() { return currentFrame; }
     void SetTitle(char *);   // Set trajectory title.
     void PrintInfo(int);     // Print trajectory Information
-    int setupFrameInfo(int); // Set actual start/stop based on total #frames and #threads 
-    int Begin(int *, int);   /* Prepare traj for processing. Set output start value, calcd in 
-                              * setupFrameInfo. Allocate memory for F. 
-                              */
-    int Begin();                 // Prepare trajectory for output
-    int NextFrame(int*);         // Put the next target frame into F.
-    void End();                  // Close trajectory and free F memory
-    void progressBar();          // Display trajectory progress to screen
-//    void progressBar2();         // Display trajectory progress to screen
-   
-    void SetArgs(int,int,int);   // Set the stop, start, and offset args from user input
+    int Begin(int *, int);   // Prepare traj for processing. Set output start value, calcd in 
+                             // setupFrameInfo. Allocate memory for F. 
+    int Begin();             // Prepare trajectory for output
+    int NextFrame(int*);     // Put the next target frame into F.
+    void End();              // Close trajectory and free F memory
+    void progressBar();      // Display trajectory progress to screen
+//    void progressBar2();   // Display trajectory progress to screen
+    int setupFrameInfo(int,int,int); // Set actual start/stop based on total #frames and #threads 
+    void SetArgs(int,int,int);       // Set the stop, start, and offset args from user input
     // --== Inherited by child classes ==--
-    virtual int getFrame(int)      { return 1; } // Read the next coord frame into F
+    virtual int getFrame(int)      { return 1; } // Read specified frame into F
     virtual int SetupRead()        { return 1; } // Set file up for reading
     virtual int WriteArgs(ArgList*){ return 0; } // (Opt.) Process any args related to writing
     virtual int SetupWrite()       { return 1; } // Set file up for writing
diff -urN amber11//AmberTools/src/cpptraj/src/TrajinList.cpp amber11.new//AmberTools/src/cpptraj/src/TrajinList.cpp
--- amber11//AmberTools/src/cpptraj/src/TrajinList.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/TrajinList.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -70,7 +70,7 @@
  * actual start and stop and how many frames total will be processed.
  * Return the number of frames to be processed.
  */
-int TrajinList::SetupFrames() {
+int TrajinList::SetupFrames(int worldrank, int worldsize) {
   int maxFrames, trajFrames;
 
   mprintf("\nTRAJECTORIES:\n");
@@ -78,7 +78,7 @@
   maxFrames=0;
 
   for (it = this->begin(); it != this->end(); it++) {
-    trajFrames = (*it)->setupFrameInfo(maxFrames);
+    trajFrames = (*it)->setupFrameInfo(maxFrames,worldrank,worldsize);
     if (trajFrames==-1) {
       maxFrames=-1;
     }
diff -urN amber11//AmberTools/src/cpptraj/src/TrajinList.h amber11.new//AmberTools/src/cpptraj/src/TrajinList.h
--- amber11//AmberTools/src/cpptraj/src/TrajinList.h	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/TrajinList.h	2011-05-19 18:35:57.000000000 +0300
@@ -13,7 +13,7 @@
     // NOTE: worldsize is passed in as last arg to avoid include of PtrajMpi
     int Add(ArgList *A, ParmFileList *, int);
     // TRAJIN: Set up frames to be processed 
-    int SetupFrames();
+    int SetupFrames(int,int);
 };
 #endif
 
diff -urN amber11//AmberTools/src/cpptraj/src/TrajoutList.cpp amber11.new//AmberTools/src/cpptraj/src/TrajoutList.cpp
--- amber11//AmberTools/src/cpptraj/src/TrajoutList.cpp	2011-04-14 15:30:16.000000000 +0300
+++ amber11.new//AmberTools/src/cpptraj/src/TrajoutList.cpp	2011-05-19 18:35:57.000000000 +0300
@@ -20,7 +20,6 @@
  */
 int TrajoutList::Add(ArgList *A, ParmFileList *parmFileList, int worldsize) {
   TrajFile *T;
-  int boxInfo;
   FileFormat writeFormat;
   FileType writeType;
   char *onlyframes; 
@@ -29,7 +28,6 @@
   if (this->ProcessArgList(A,parmFileList)) return 1;
 
   // Init variables
-  boxInfo=0;
   writeFormat=AMBERTRAJ; 
   writeType=UNKNOWN_TYPE;
  
@@ -56,10 +54,6 @@
   if (worldsize>1 && writeFormat!=AMBERRESTART) 
     writeType=MPIFILE;
 
-  // Set box info from parm file unless nobox is set.
-  boxInfo=P->ifbox;
-  if (A->hasKey("nobox")) boxInfo=0;
-
   // Set up basic file for given type and format
   // If type is unknown it will be determined from extension or will be standard (default)
   T = this->SetupTrajectory(trajfilename, fileAccess, writeFormat, writeType);
@@ -90,10 +84,11 @@
   // Set parameter file
   T->P=P;
 
-  // Set box information (only needed for write)
-  T->isBox=boxInfo;
+  // Set box type from parm file unless "nobox" specified  
+  T->BoxType=P->BoxType;
+  if (A->hasKey("nobox")) T->BoxType=0;
 
-  // No setup here; Write is set up after first frame read in PtrajState::Run
+  // No more setup here; Write is set up when first frame written.
   // Add to trajectory file list
   this->push_back(T); 
 
diff -urN amber11//AmberTools/src/leap/src/leap/amber.c amber11.new//AmberTools/src/leap/src/leap/amber.c
--- amber11//AmberTools/src/leap/src/leap/amber.c	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/amber.c	2011-05-19 18:35:57.000000000 +0300
@@ -36,6 +36,10 @@
  *              UNITs and PARMSETs.
  */
 
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*   	 Added SCEE/SCNB   	*/
+
 #include        "basics.h"
 #include        "vector.h"
 #include        "classes.h"
@@ -240,23 +244,47 @@
  *
  *      Read the proper torsion parameter terms.
  */
+
+/* Arunima Singh added reading in of scee and scnb fields for proper torsions 20110420 */
 static void
 zAmberReadParmSetPropers( PARMSET psParms, FILE *fIn )
 {
 STRING          sLine;
-int             iRead, iN;
+int             iRead, iN, iRead2, iRead3;
 STRING          saStr[10];
-double          dDivisions, dKp, dP0, dN;
+double          dDivisions, dKp, dP0, dN, dScee, dScnb;
+char		*cScee, *cScnb;
 
     memset(saStr, 0, sizeof(saStr));                    /* for Purify */
     while (1) {
         FGETS( sLine, fIn );
         NODASHES(sLine);
-        iRead = sscanf( sLine, "%s %s %s %s %lf %lf %lf %lf", 
+
+	iRead = sscanf( sLine, "%s %s %s %s %lf %lf %lf %lf ", 
                                 saStr[0], saStr[1], saStr[2], saStr[3], 
                                 &dDivisions, &dKp, &dP0, &dN );
-        if ( iRead <= 0 ) 
+
+	cScee = strstr(sLine, "SCEE");
+	if(cScee!=NULL) {
+		iRead2 = sscanf( cScee, "SCEE=%lf", &dScee);
+		iRead++;
+		}
+
+        cScnb = strstr(sLine, "SCNB");	
+        if(cScnb!=NULL) {
+                iRead3 = sscanf( cScnb, "SCNB=%lf", &dScnb);
+                iRead++;
+                }
+
+	if ( iRead <= 0 ) 
                 break;
+
+	if ( iRead == 8 )	/*Arunima Singh*/
+	{
+		dScee = 1.2;
+		dScnb = 2.0;
+	}
+	
         MESSAGE(( "Read: %s\n", sLine ));
 
         if ( sLine[0] == ' ' && sLine[1] == ' ') {
@@ -277,14 +305,37 @@
         zAmberConvertWildCard( saStr[3] );
         iParmSetAddProperTerm( psParms, 
                                 saStr[0], saStr[1], saStr[2], saStr[3],
-                                abs(iN), dKp, dP0*DEGTORAD, "" );
+                                abs(iN), dKp, dP0*DEGTORAD, dScee, dScnb, "" );
+
+
         while( iN < 0 ) {
                 FGETS( sLine, fIn );
                 NODASHES(sLine);
                 MESSAGE(( "Read extra term: %s\n", sLine ));
-                iRead = sscanf( &sLine[11], "%lf %lf %lf %lf",
+                iRead = sscanf( &sLine[11], "%lf %lf %lf %lf ",
                                 &dDivisions, &dKp, &dP0, &dN );
-                if ( iRead<=0 ) break;
+               
+	        cScee = strstr(sLine, "SCEE");
+        	if(cScee!=NULL) {
+                	iRead2 = sscanf( cScee, "SCEE=%lf", &dScee);
+	                iRead++;
+        	        }
+
+	        cScnb = strstr(sLine, "SCNB");
+        	if(cScnb!=NULL) {
+	                iRead3 = sscanf( cScnb, "SCNB=%lf", &dScnb);
+        	        iRead++;
+                	}
+ 
+
+	        if ( iRead == 4 )       /*Arunima Singh*/
+	        {
+	                dScee = 1.2;
+                	dScnb = 2.0;
+        	}
+
+
+		if ( iRead<=0 ) break;
 
                 if ( dDivisions == 0.0 ) 
                         dDivisions = 1.0;
@@ -292,7 +343,7 @@
                 iN = (int)floor(dN+0.5);
                 iParmSetAddProperTerm( psParms,
                                 saStr[0], saStr[1], saStr[2], saStr[3],
-                                abs(iN), dKp, dP0*DEGTORAD, "" );
+                                abs(iN), dKp, dP0*DEGTORAD, dScee, dScnb, "" );
         }
         if ( iRead <= 0 )
                 break;
@@ -311,7 +362,7 @@
 STRING          sLine;
 int             iRead, iN;
 STRING          saStr[10];
-double          dKp, dP0, dN;
+double          dKp, dP0, dN, dScee, dScnb;
 BOOL            bPrintLine;
 
     memset(saStr, 0, sizeof(saStr));                    /* for Purify */
@@ -335,6 +386,8 @@
         zAmberConvertWildCard( saStr[2] );
         zAmberConvertWildCard( saStr[3] );
         iN = (int)dN;
+	dScee = 0.0;
+	dScnb = 0.0;
 
         /*
          *  check everything in case a format or other user error
@@ -362,7 +415,7 @@
 
         iParmSetAddImproperTerm( psParms, 
                                 saStr[0], saStr[1], saStr[2], saStr[3],
-                                iN, dKp, dP0*DEGTORAD, "" );
+                                iN, dKp, dP0*DEGTORAD, dScee, dScnb, "" );
     }
     if ( iRead > 0 )
         VP0(( "WARNING: incomplete Improper Torsion line:\n%s", sLine ));
diff -urN amber11//AmberTools/src/leap/src/leap/build.c amber11.new//AmberTools/src/leap/src/leap/build.c
--- amber11//AmberTools/src/leap/src/leap/build.c	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/build.c	2011-05-19 18:35:57.000000000 +0300
@@ -42,8 +42,9 @@
  *		
  */
 
-
-
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB   	*/
 
 #include	"basics.h"
 
@@ -1567,7 +1568,7 @@
 LOOP            lAtoms, lTemp;
 ATOM            aAtom, aAtom1, aAtom2, aAtom3, aAtom4;
 BOOL            bM1, bM2, bM3, bM4, bOneMinimizedAtom;
-double          dKb, dR0, dKt, dT0, dTkub, dRkub, dKp, dP0;
+double          dKb, dR0, dKt, dT0, dTkub, dRkub, dKp, dP0, dScee, dScnb;
 STRING		sAtom1, sAtom2, sAtom3, sAtom4, sDesc;
 PARMSET		psTemp;
 TORSION		tTorsion;
@@ -1757,7 +1758,7 @@
 	    ParmSetTORSIONTerm( tTorsion, i,
 	    		&iIndex,
 			sAtom1, sAtom2, sAtom3, sAtom4,
-			&iN, &dKp, &dP0, sDesc );
+			&iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
 	    if ( !bMinimizerAddTorsion( mStrain, 
 	    				aAtom1, aAtom2, aAtom3, aAtom4,
 					(double)iN, dKp, dP0 )) {
diff -urN amber11//AmberTools/src/leap/src/leap/model.c amber11.new//AmberTools/src/leap/src/leap/model.c
--- amber11//AmberTools/src/leap/src/leap/model.c	2011-04-14 15:30:17.000000000 +0300
+++ amber11.new//AmberTools/src/leap/src/leap/model.c	2011-05-19 18:35:57.000000000 +0300
@@ -39,7 +39,9 @@
  *              are determined from atom types.
  */
 
-
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
 
 
 #include	"basics.h"
@@ -781,16 +783,6 @@
 	    maPAtom++;
 	}
     }
-    if ( iAtomCoordination(aX) != 
-          1 + maPAtom - &(mtTorsions.maaXBonds[0]) ) {
-	VP0(( "Error: Atom %s has force field coordination %i\n"
-	      "       but only %i bonded neighbors.\n"
-	      "       The cause may be an incorrect atom type, and\n"
-	      "       the effect may be a crash very soon.\n",
-	      sContainerFullDescriptor((CONTAINER)aX,s1),
-	      iAtomCoordination(aX),
-	      1 + maPAtom - &(mtTorsions.maaXBonds[0]) ));
-    }
     for ( i=iAtomCoordination(aX); i<MAXBONDS; i++ ) {
 	maPAtom->aAtom = NULL;
 	maPAtom++;
@@ -824,16 +816,6 @@
 	    maPAtom++;
 	}
     }
-    if ( iAtomCoordination(aY) != 
-          1 + maPAtom - &(mtTorsions.maaYBonds[0]) ) {
-	VP0(( "Error: Atom %s has force field coordination %i\n"
-	      "       but only %i bonded neighbors.\n"
-	      "       The cause may be an incorrect atom type, and\n"
-	      "       the effect may be a crash very soon.\n",
-	      sContainerFullDescriptor((CONTAINER)aY,s1),
-	      iAtomCoordination(aY),
-	      1 + maPAtom - &(mtTorsions.maaYBonds[0]) ));
-    }
     for ( i=iAtomCoordination(aY); i<MAXBONDS; i++ ) {
 	maPAtom->aAtom = NULL;
 	maPAtom++;
@@ -1205,6 +1187,8 @@
 		int	iN;
 		double	dK;
 		double	dE;
+		double  dSce;	/*Arunima Singh*/
+		double  dScn;	/*Arunima Singh*/
 		} H_PROPERPARMt;
 
 typedef	struct	{
@@ -1222,12 +1206,13 @@
 
 	/* Keep iHybrid2 <= iHybrid3 */
 
+/* Arunima Singh 20110413. Added Scee and Scnb AMBER defaults of 1.2 and 2.0 */
 #define	TFORCE	20.0
 static	H_PROPERPARMt	SppaPropers[] = {
-{ 	HSP3,	HSP3,	3,	1.0,		0.0 },	/* Non bond */
-{ 	HSP2,	HSP3,	6,	-2.0,		0.0 },	/* Non bond */
-{	HSP2,	HSP2,	2,	-4.0,		0.0 },	/* Pi bond overlap */
-{	HSP1,	HSP1,	1,	0.0,		0.0 }	/* Not interesting */
+{ 	HSP3,	HSP3,	3,	1.0,		0.0,	1.2,	2.0 },	/* Non bond */
+{ 	HSP2,	HSP3,	6,	-2.0,		0.0,    1.2,    2.0 },	/* Non bond */
+{	HSP2,	HSP2,	2,	-4.0,		0.0,    1.2,    2.0 },	/* Pi bond overlap */
+{	HSP1,	HSP1,	1,	0.0,		0.0,    1.2,    2.0 }	/* Not interesting */
 };
 
 #define	AFORCE	100.0
@@ -1290,6 +1275,8 @@
 					SppaPropers[i].iN,
 					SppaPropers[i].dK,
 					SppaPropers[i].dE,
+					SppaPropers[i].dSce,
+					SppaPropers[i].dScn,
 					sDesc );
 	}
     }
diff -urN amber11//AmberTools/src/leap/src/leap/parmSet.c amber11.new//AmberTools/src/leap/src/leap/parmSet.c
--- amber11//AmberTools/src/leap/src/leap/parmSet.c	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/parmSet.c	2011-05-19 18:35:57.000000000 +0300
@@ -54,7 +54,9 @@
  *		search routines REQUIRE pre-ordering.
  */
 
-
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
 
 #include	"basics.h"
 
@@ -965,6 +967,8 @@
 	/*
 	 *  copy into 1 vararray & set iType
 	 */
+	
+	/*Arunima Singh added scee and scnb into the database */
 	vaTorsTypes = vaVarArrayCopy2( psLib->vaTorsions, psLib->vaImpropers );
 	tP = PVAI(vaTorsTypes,TORSIONPARMt,0);
 	for (i=0; i<iVarArrayElementCount(psLib->vaTorsions); i++, tP++)
@@ -980,8 +984,12 @@
                 7, "n",
 		    (char *)&(PVAI(vaTorsTypes,TORSIONPARMt,0)->iN),
 		    iVarArrayElementSize(vaTorsTypes),
-                0, NULL, NULL, 0,
-                0, NULL, NULL, 0,
+                9, "scee", 
+		    (char *)&(PVAI(vaTorsTypes,TORSIONPARMt,0)->dScee), 
+		    iVarArrayElementSize(vaTorsTypes),
+                10, "scnb", 
+		    (char *)&(PVAI(vaTorsTypes,TORSIONPARMt,0)->dScnb), 
+		    iVarArrayElementSize(vaTorsTypes),
                 0, NULL, NULL, 0,
                 0, NULL, NULL, 0,
                 0, NULL, NULL, 0,
@@ -1008,7 +1016,7 @@
                 4, "type4",
 		    (char *)&(PVAI(vaTorsTypes,TORSIONPARMt,0)->sType4),
                     iVarArrayElementSize(vaTorsTypes),
-                9, "desc",
+                11, "desc",
 		    (char *)&(PVAI(vaTorsTypes,TORSIONPARMt,0)->sDesc),
                     iVarArrayElementSize(vaTorsTypes)
                 );
@@ -1586,10 +1594,15 @@
  *      Add a torsion parameter to the PARMSET.
  *      Return the index. 
  */
+
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
+
 int
 iParmSetAddProperTerm( PARMSET psLib, 
 	char *sType1, char *sType2, char *sType3, char *sType4, 
-	int iN, double dKp, double dP0, char *sDesc )
+	int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc )
 {
 TORSIONPARMt    tpTorsion;
 
@@ -1605,6 +1618,8 @@
     tpTorsion.dKp = dKp;
     tpTorsion.iN  = iN;
     tpTorsion.dP0 = dP0;
+    tpTorsion.dScee = dScee;
+    tpTorsion.dScnb = dScnb;
     strcpy( tpTorsion.sOrder, "0123" );
     if ( sDesc != NULL )
     	strcpy( tpTorsion.sDesc, sDesc );
@@ -1633,7 +1648,7 @@
 int
 iParmSetAddImproperTerm( PARMSET psLib, 
 	char *sType1, char *sType2, char *sType3, char *sType4, 
-	int iN, double dKp, double dP0, char *sDesc )
+	int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc )
 {
 TORSIONPARMt    tpImproper;
 orderStr	sOrder;
@@ -2022,7 +2037,7 @@
 void
 ParmSetTORSIONTerm( TORSION tTorsion, int iTorsionIndex, int *iPParmSetIndex,
 		   char *cPType1, char *cPType2, char *cPType3, char *cPType4,
-		   int *iPN, double *dPKp, double *dPP0, char *sDesc )
+		   int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDesc )
 {
 TORSION_MATCHt	*tmPCur;
 
@@ -2035,6 +2050,8 @@
     *iPN = tmPCur->tpTorsion.iN;
     *dPKp = tmPCur->tpTorsion.dKp;
     *dPP0 = tmPCur->tpTorsion.dP0;
+    *dPScee = tmPCur->tpTorsion.dScee;
+    *dPScnb = tmPCur->tpTorsion.dScnb;
     strcpy(sDesc, tmPCur->tpTorsion.sDesc);
 }
 
@@ -2050,7 +2067,7 @@
 BOOL
 bParmSetTORSIONAddProperTerm( TORSION tTorsion,
 	char *cPType1, char *cPType2, char *cPType3, char *cPType4,
-	int iN, double dKp, double dP0, char *sDesc )
+	int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc )
 {
 TORSIONPARMt	tpTorsion;
 
@@ -2066,6 +2083,8 @@
     tpTorsion.iN = iN;
     tpTorsion.dKp = dKp;
     tpTorsion.dP0 = dP0;
+    tpTorsion.dScee = dScee;
+    tpTorsion.dScnb = dScnb;
     strcpy(tpTorsion.sDesc, sDesc);
     strcpy( tpTorsion.sOrder, "0123" );
     
@@ -2087,7 +2106,7 @@
 BOOL
 bParmSetTORSIONAddImproperTerm( TORSION tTorsion,
 	char *cPType1, char *cPType2, char *cPType3, char *cPType4,
-	int iN, double dKp, double dP0, char *sDesc )
+	int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc )
 {
 TORSIONPARMt	tpTorsion;
 orderStr	sOrder;
@@ -2104,6 +2123,8 @@
     tpTorsion.iN = iN;
     tpTorsion.dKp = dKp;
     tpTorsion.dP0 = dP0;
+    tpTorsion.dScee = dScee;
+    tpTorsion.dScnb = dScnb;
     strcpy(tpTorsion.sDesc, sDesc);
     strcpy( tpTorsion.sOrder, sOrder );
     
@@ -2516,7 +2537,7 @@
 void
 ParmSetTorsion( PARMSET psLib, int i, 
 	char *sType1, char *sType2, char *sType3, char *sType4,
-	int *iPN, double *dPKp, double *dPP0, char *sDesc)
+	int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDesc)
 {
 TORSIONPARMt   *tpPTorsion;
 
@@ -2531,6 +2552,8 @@
 	strcpy( sType4, WILD_CARD_TYPE );
 	*iPN  = 0;
 	*dPKp = 0;
+	*dPScee = 0;
+        *dPScnb = 0;
 	*dPP0 = 0;
 	strcpy( sDesc, "??" );
 	return;
@@ -2543,7 +2566,10 @@
     *iPN  = tpPTorsion->iN;
     *dPKp = tpPTorsion->dKp;
     *dPP0 = tpPTorsion->dP0;
+    *dPScee = tpPTorsion->dScee;
+    *dPScnb = tpPTorsion->dScnb; 
     strcpy( sDesc, tpPTorsion->sDesc );
+
 }
 
 
@@ -2557,7 +2583,7 @@
 void    
 ParmSetImproper( PARMSET psLib, int i, 
 	char *sType1, char *sType2, char *sType3, char *sType4,
-	int *iPN, double *dPKp, double *dPP0, char *sDesc)
+	int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDesc)
 {
 TORSIONPARMt   *tpPImproper;
 
@@ -2573,6 +2599,8 @@
 	*iPN  = 0;
 	*dPKp = 0;
 	*dPP0 = 0;
+	*dPScee = 0;
+	*dPScnb = 0;
 	strcpy( sDesc, "??" );
 	return;
     }
@@ -2584,6 +2612,8 @@
     *iPN  = tpPImproper->iN;
     *dPKp = tpPImproper->dKp;
     *dPP0 = tpPImproper->dP0;
+    *dPScee = tpPImproper->dScee;
+    *dPScnb = tpPImproper->dScnb;
     strcpy( sDesc, tpPImproper->sDesc );
 }
 
@@ -2740,7 +2770,7 @@
 void
 ParmSetUpdateTorsion( PARMSET psLib, int i, 
 	char *sType1, char *sType2, char *sType3, char *sType4,
-	int *iPN, double *dPKp, double *dPP0, char *sDescription)
+	int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDescription)
 {
 TORSIONPARMt	*tpPTorsion;
 orderStr	sOrder;
@@ -2754,6 +2784,8 @@
     if (         iPN != (int*)NULL   ) tpPTorsion->iN = *iPN;
     if (        dPKp != (double*)NULL) tpPTorsion->dKp = *dPKp;
     if (        dPP0 != (double*)NULL) tpPTorsion->dP0 = *dPP0;
+    if (      dPScee != (double*)NULL) tpPTorsion->dScee = *dPScee;
+    if (      dPScnb != (double*)NULL) tpPTorsion->dScnb = *dPScnb;
     if (sDescription != (char*)NULL  ) strcpy(tpPTorsion->sDesc, sDescription);
 
     strcpy( sOrder, "0123" );
@@ -2777,7 +2809,7 @@
 void
 ParmSetUpdateImproper( PARMSET psLib, int i, 
 	char *sType1, char *sType2, char *sType3, char *sType4,
-	int *iPN, double *dPKp, double *dPP0, char *sDescription)
+	int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDescription)
 {
 TORSIONPARMt   *tpPTorsion;
 orderStr	sOrder;
@@ -2790,6 +2822,8 @@
     if (         iPN != (int*)NULL   ) tpPTorsion->iN = *iPN;
     if (        dPKp != (double*)NULL) tpPTorsion->dKp = *dPKp;
     if (        dPP0 != (double*)NULL) tpPTorsion->dP0 = *dPP0;
+    if (      dPScee != (double*)NULL) tpPTorsion->dScee = *dPScee;
+    if (      dPScnb != (double*)NULL) tpPTorsion->dScnb = *dPScnb;
     if (sDescription != (char*)NULL  ) strcpy(tpPTorsion->sDesc, sDescription);
 
     strcpy( sOrder, "0123" );
@@ -2979,6 +3013,7 @@
 			tpPCur->sType1, tpPCur->sType2, 
 			tpPCur->sType3, tpPCur->sType4,
 			tpPCur->iN, tpPCur->dKp, tpPCur->dP0/DEGTORAD,
+			tpPCur->dScee, tpPCur->dScnb,
 			tpPCur->sOrder, tpPCur->sDesc );
 	}
 }
@@ -2996,6 +3031,7 @@
 			tpPCur->sType1, tpPCur->sType2, 
 			tpPCur->sType3, tpPCur->sType4,
 			tpPCur->iN, tpPCur->dKp, tpPCur->dP0/DEGTORAD, 
+			tpPCur->dScee, tpPCur->dScnb,
 			tpPCur->sDesc );
 	}
 }
diff -urN amber11//AmberTools/src/leap/src/leap/parmSet.h amber11.new//AmberTools/src/leap/src/leap/parmSet.h
--- amber11//AmberTools/src/leap/src/leap/parmSet.h	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/parmSet.h	2011-05-19 18:35:57.000000000 +0300
@@ -42,6 +42,9 @@
  *
  *
  */
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
  
 #ifndef PARMSET_H
 #define PARMSET_H
@@ -96,6 +99,8 @@
 	int		iN;
 	double          dKp;
 	double          dP0;
+	double		dScee;		/* for propers */ /* Arunima Singh */ 
+	double          dScnb;		/* for propers */ /* Arunima Singh */
 	orderStr	sOrder;		/* for impropers */
 	DESCRIPTION     sDesc;
 } TORSIONPARMt;
@@ -158,10 +163,10 @@
 			double dKt, double dT0, double dTkub, double dRkub, char *sDesc);
 extern int	iParmSetAddProperTerm(PARMSET psLib,
 			char *sType1, char *sType2, char *sType3, char *sType4,
-			int iN, double dKp, double dP0, char *sDesc);
+			int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc);	/* for proper dihedrals */ /* Arunima Singh */
 extern int	iParmSetAddImproperTerm(PARMSET psLib,
 			char *sType1, char *sType2, char *sType3, char *sType4,
-			int iN, double dKp, double dP0, char *sDesc);
+			int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc);	/* Arunima Singh : added for proper dihedrals, but has to be included in impropers to maintain common data structure usage */ 
 extern int	iParmSetAddHBond(PARMSET psLib, char *sType1, char *sType2,
 			double dA, double dB, char *sDesc);
 
@@ -216,15 +221,15 @@
 extern void	ParmSetTORSIONTerm(TORSION tTorsion, int iTorsionIndex, 
 			int *iPParmSetIndex,
 			char *cPTyp1, char *cPTyp2, char *cPTyp3, char *cPTyp4,
-			int *iPN, double *dPKp, double *dPP0, char *sDesc );
+			int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDesc );
 extern BOOL	bParmSetTORSIONAddProperTerm(TORSION tTorsion,
 			char *cPType1, char *cPType2, 
 			char *cPType3, char *cPType4,
-			int iN, double dKp, double dP0, char *sDesc);
+			int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc);
 extern BOOL	bParmSetTORSIONAddImproperTerm(TORSION tTorsion,
 			char *cPType1, char *cPType2, 
 			char *cPType3, char *cPType4,
-			int iN, double dKp, double dP0, char *sDesc);
+			int iN, double dKp, double dP0, double dScee, double dScnb, char *sDesc);
 extern void	ParmSetTORSIONOrderAtoms();	
 extern void	ParmSetImproperOrderAtoms( TORSION tTorsion, int iTorsionIndex,
 			char *cPaTypes[4], int iaIndexes[4] );
@@ -268,10 +273,10 @@
 			char *sDesc);
 extern void	ParmSetTorsion(PARMSET psLib, int i,
 			char *sType1, char *sType2, char *sType3, char *sType4,
-			int *iPN, double *dPKp, double *dPP0, char *sDesc);
+			int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDesc);
 extern void	ParmSetImproper(PARMSET psLib, int i,
 			char *sType1, char *sType2, char *sType3, char *sType4,
-			int *iPN, double *dPKp, double *dPP0, char *sDesc);
+			int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb, char *sDesc);
 extern void	ParmSetHBond(PARMSET psLib, int i, char *sType1, char *sType2,
 			double *dPA, double *dPB, char *sDesc);
 
@@ -296,11 +301,11 @@
 			double *dPKt, double *dPT0, char *sDescription);
 extern void	ParmSetUpdateTorsion(PARMSET psLib, int i,
 			char *sType1, char *sType2, char *sType3, char *sType4,
-			int *iPN, double *dPKp, double *dPP0, 
+			int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb,
 			char *sDescription);
 extern void	ParmSetUpdateImproper(PARMSET psLib, int i,
 			char *sType1, char *sType2, char *sType3, char *sType4,
-			int *iPN, double *dPKp, double *dPP0, 
+			int *iPN, double *dPKp, double *dPP0, double *dPScee, double *dPScnb,
 			char *sDescription);
 extern void	ParmSetUpdateHBond(PARMSET psLib, int i, 
 			char *sType1, char *sType2,
diff -urN amber11//AmberTools/src/leap/src/leap/unitio.c amber11.new//AmberTools/src/leap/src/leap/unitio.c
--- amber11//AmberTools/src/leap/src/leap/unitio.c	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/unitio.c	2011-05-19 18:35:57.000000000 +0300
@@ -70,6 +70,10 @@
 *       zbUnitIOIndexBondParameters and zUnitDoAtoms are now "extern functions" 
 */ 
 
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
+
 #include <time.h>
 
 #include        "basics.h"
@@ -1585,7 +1589,9 @@
         tC.dKp = tpA->dKp;
         tC.iN = tpA->iN;
         tC.dP0 = tpA->dP0;
-        VarArrayAdd(vaB, (GENP) & tC);
+        tC.dScee = tpA->dScee;
+	tC.dScnb = tpA->dScnb;
+	VarArrayAdd(vaB, (GENP) & tC);
         iIndex++;
         iOldIndex = iParmOffset + iA + 1;
 
@@ -1615,6 +1621,10 @@
                 continue;
             if (tpB->dP0 != tpA->dP0)
                 continue;
+	    if (tpB->dScee != tpA->dScee)
+                continue;
+            if (tpB->dScnb != tpA->dScnb)
+                continue;
 
             /*
              *  B is a duplicate of A
@@ -1698,12 +1708,12 @@
     int iTerm, iPertTerm;
     BOOL bDone, bUse, bUsePert, bCopy, bCopyPert, bEnd, bPertEnd;
     int iN, iPertIndex, iPertN, iLastN, iLastPertN;
-    double dKp, dP0, dPertKp, dPertP0;
+    double dKp, dP0, dScee, dScnb, dPertKp, dPertP0, dPertScee, dPertScnb;
     BOOL bCalc14, bCalcPert14;
 #ifdef  DEBUG2
     STRING s1, s2, s3, s4;
     int iTParm, iTmp;
-    double dTK, dTP;
+    double dTK, dTP, dTScee, dTScnb;
     STRING sT1, sT2, sT3, sT4, sTemp;
 #endif
         STRING sDesc;
@@ -2016,9 +2026,9 @@
             ParmSetTORSIONTerm(tTorsion, i,
                                &iTParm,
                                sT1, sT2, sT3, sT4,
-                               &iTmp, &dTK, &dTP, sTemp);
-            MESSAGE(("Term %3d  %d %s-%s-%s-%s  %d  %lf  %lf\n",
-                     i, iTParm, sT1, sT2, sT3, sT4, iTmp, dTK, dTP));
+                               &iTmp, &dTK, &dTP, &dTScee, &dTScnb, sTemp);
+            MESSAGE(("Term %3d  %d %s-%s-%s-%s  %d  %lf  %lf %lf %lf\n",
+                     i, iTParm, sT1, sT2, sT3, sT4, iTmp, dTK, dTP, dTScee, dTScnb));
         }
         if (bPerturbTorsion) {
             MESSAGE(("Pert%s %s-%s-%s-%s found %d terms\n",
@@ -2029,9 +2039,9 @@
                 ParmSetTORSIONTerm(tPertTorsion, i,
                                    &iTParm,
                                    sT1, sT2, sT3, sT4,
-                                   &iTmp, &dTK, &dTP, sTemp);
-                MESSAGE(("Term %3d  %d %s-%s-%s-%s  %d  %lf  %lf\n",
-                         i, iTParm, sT1, sT2, sT3, sT4, iTmp, dTK, dTP));
+                                   &iTmp, &dTK, &dTP, &dTScee, &dTScnb, sTemp);
+                MESSAGE(("Term %3d  %d %s-%s-%s-%s  %d  %lf  %lf %lf %lf\n",
+                         i, iTParm, sT1, sT2, sT3, sT4, iTmp, dTK, dTP dTScee, dTScnb));
             }
         }
 #endif
@@ -2061,7 +2071,7 @@
             ParmSetTORSIONTerm(tTorsion, iTerm,
                                &iIndex,
                                sAtom1, sAtom2, sAtom3, sAtom4,
-                               &iN, &dKp, &dP0, sDesc);
+                               &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
             MESSAGE(("First non-perturbed multiplicity: %d\n", iN));
         } else {
             if (bProper) {
@@ -2082,7 +2092,7 @@
                 ParmSetTORSIONTerm(tPertTorsion, iPertTerm,
                                    &iPertIndex,
                                    sPert1, sPert2, sPert3, sPert4,
-                                   &iPertN, &dPertKp, &dPertP0, sDesc);
+                                   &iPertN, &dPertKp, &dPertP0, &dPertScee, &dPertScnb, sDesc);
                 MESSAGE(("First perturbed multiplicity: %d\n", iPertN));
             } else
                 bPertEnd = TRUE;
@@ -2175,14 +2185,14 @@
                 if (bProper)
                     iIndex = iParmSetAddProperTerm(uUnit->psParameters,
                                                    sAtom1, sAtom2, sAtom3,
-                                                   sAtom4, iN, dKp, dP0,
-                                                   sDesc);
+                                                   sAtom4, iN, dKp, dP0, 
+                                                   dScee, dScnb, sDesc);
 /*                else if ( !GDefaults.iCharmm )    ???---should I do this????     */
                 else
                     iIndex = iParmSetAddImproperTerm(uUnit->psParameters,
                                                      sAtom1, sAtom2,
                                                      sAtom3, sAtom4, iN,
-                                                     dKp, dP0, sDesc);
+                                                     dKp, dP0, dScee, dScnb, sDesc);
             }
             if (bCopyPert) {
                 if (bProper) {
@@ -2190,13 +2200,13 @@
                                                        sPert1, sPert2,
                                                        sPert3, sPert4,
                                                        iPertN, dPertKp,
-                                                       dPertP0, sDesc);
+                                                       dPertP0, dScee, dScnb, sDesc);
                 } else {
                     iPertIndex =
                         iParmSetAddImproperTerm(uUnit->psParameters,
                                                 sPert1, sPert2, sPert3,
                                                 sPert4, iPertN, dPertKp,
-                                                dPertP0, sDesc);
+                                                dPertP0, dScee, dScnb, sDesc);
                 }
                 MESSAGE(("iPertIndex = %d\n", iPertIndex));
             }
@@ -2215,7 +2225,7 @@
                     ParmSetTORSIONTerm(tTorsion, iTerm,
                                        &iIndex,
                                        sAtom1, sAtom2, sAtom3, sAtom4,
-                                       &iN, &dKp, &dP0, sDesc);
+                                       &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
                 }
                 MESSAGE(
                         ("Advancing non-perturbed multiplicity to %d\n",
@@ -2231,7 +2241,7 @@
                     ParmSetTORSIONTerm(tPertTorsion, iPertTerm,
                                        &iPertIndex,
                                        sPert1, sPert2, sPert3, sPert4,
-                                       &iPertN, &dPertKp, &dPertP0, sDesc);
+                                       &iPertN, &dPertKp, &dPertP0, &dPertScee, &dPertScnb, sDesc);
                 }
                 MESSAGE(
                         ("Advancing perturbed multiplicity to %d\n",
@@ -3988,7 +3998,7 @@
     SAVEATOMt *saPAtom;
     SAVETORSIONt *stPTorsion;
     SAVERESTRAINTt *srPRestraint;
-    double dMass, dPolar, dR, dKb, dR0, dKt, dT0, dTkub, dRkub, dKp, dP0,
+    double dMass, dPolar, dR, dKb, dR0, dKt, dT0, dTkub, dRkub, dKp, dP0, dScee, dScnb,
         dC, dD, dTemp;
     STRING sAtom1, sAtom2, sAtom3, sAtom4, sType1, sType2;
     int iN, iAtoms, iMaxAtoms, iTemp, iAtom, iCalc14, iProper;
@@ -4585,16 +4595,16 @@
              iParmSetTotalImproperParms(uUnit->psParameters)));
     for (i = 0; i < iParmSetTotalTorsionParms(uUnit->psParameters); i++) {
         ParmSetTorsion(uUnit->psParameters, i, sAtom1, sAtom2,
-                       sAtom3, sAtom4, &iN, &dKp, &dP0, sDesc);
-        MESSAGE(("Torsion %d  %s-%s-%s-%s %d %lf %lf\n",
-                 i, sAtom1, sAtom2, sAtom3, sAtom4, iN, dKp, dP0));
+                       sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
+        MESSAGE(("Torsion %d  %s-%s-%s-%s %d %lf %lf %lf %lf\n",
+                 i, sAtom1, sAtom2, sAtom3, sAtom4, iN, dKp, dP0, dScee, dScnb));
         FortranWriteDouble(dKp);
     }
     for (i = 0; i < iParmSetTotalImproperParms(uUnit->psParameters); i++) {
         ParmSetImproper(uUnit->psParameters, i, sAtom1, sAtom2,
-                        sAtom3, sAtom4, &iN, &dKp, &dP0, sDesc);
-        MESSAGE(("Improper %d  %s-%s-%s-%s %d %lf %lf\n",
-                 i, sAtom1, sAtom2, sAtom3, sAtom4, iN, dKp, dP0));
+                        sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
+        MESSAGE(("Improper %d  %s-%s-%s-%s %d %lf %lf %lf %lf\n",
+                 i, sAtom1, sAtom2, sAtom3, sAtom4, iN, dKp, dP0, dScee, dScnb));
         FortranWriteDouble(dKp);
     }
     /* Write the torsion RESTRAINT constants AND set the index */
@@ -4612,13 +4622,13 @@
     FortranFormat(5, DBLFORMAT);
     for (i = 0; i < iParmSetTotalTorsionParms(uUnit->psParameters); i++) {
         ParmSetTorsion(uUnit->psParameters, i, sAtom1, sAtom2,
-                       sAtom3, sAtom4, &iN, &dKp, &dP0, sDesc);
+                       sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
         dTemp = iN;
         FortranWriteDouble(dTemp);
     }
     for (i = 0; i < iParmSetTotalImproperParms(uUnit->psParameters); i++) {
         ParmSetImproper(uUnit->psParameters, i, sAtom1, sAtom2,
-                        sAtom3, sAtom4, &iN, &dKp, &dP0, sDesc);
+                        sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
         dTemp = iN;
         FortranWriteDouble(dTemp);
     }
@@ -4637,12 +4647,12 @@
     FortranFormat(5, DBLFORMAT);
     for (i = 0; i < iParmSetTotalTorsionParms(uUnit->psParameters); i++) {
         ParmSetTorsion(uUnit->psParameters, i, sAtom1, sAtom2,
-                       sAtom3, sAtom4, &iN, &dKp, &dP0, sDesc);
+                       sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
         FortranWriteDouble(dP0);
     }
     for (i = 0; i < iParmSetTotalImproperParms(uUnit->psParameters); i++) {
         ParmSetImproper(uUnit->psParameters, i, sAtom1, sAtom2,
-                        sAtom3, sAtom4, &iN, &dKp, &dP0, sDesc);
+                        sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
         FortranWriteDouble(dP0);
     }
     /* Write the torsion RESTRAINT constants AND set the index */
@@ -4650,6 +4660,60 @@
     RESTRAINTLOOP(RESTRAINTTORSION, dN, i + 1);
     FortranEndLine();
 
+	/*	Arunima Singh (UGA)	*/
+	/*	   20110420		*/
+	/*   Added Printing SCEE/SCNB	*/
+
+
+    /* -17.5A- SCEE for torsions */
+    FortranDebug("-17.5A-");
+    
+    MESSAGE(("Writing SCEE scale factor for torsion interaction\n"));
+    FortranFormat(1, "%-80s");
+    FortranWriteString("%FLAG SCEE_SCALE_FACTOR");
+    FortranWriteString("%FORMAT(5E16.8)");
+    FortranFormat(5, DBLFORMAT);
+    for (i = 0; i < iParmSetTotalTorsionParms(uUnit->psParameters); i++) {
+        ParmSetTorsion(uUnit->psParameters, i, sAtom1, sAtom2,
+                       sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
+        FortranWriteDouble(dScee);
+    }
+    for (i = 0; i < iParmSetTotalImproperParms(uUnit->psParameters); i++) {
+        ParmSetImproper(uUnit->psParameters, i, sAtom1, sAtom2,
+                        sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
+        FortranWriteDouble(dScee);
+    }
+    /* Write the torsion RESTRAINT constants AND set the index */
+    /* for where the interaction can find its constants */
+    RESTRAINTLOOP(RESTRAINTTORSION, dX0, i + 1);
+    FortranEndLine();
+
+    /* -17.5B- SCNB for torsions */
+    FortranDebug("-17.5B-");
+
+    MESSAGE(("Writing SCNB scale factor for torsion interaction\n"));
+    FortranFormat(1, "%-80s");
+    FortranWriteString("%FLAG SCNB_SCALE_FACTOR");
+    FortranWriteString("%FORMAT(5E16.8)");
+    FortranFormat(5, DBLFORMAT);
+    for (i = 0; i < iParmSetTotalTorsionParms(uUnit->psParameters); i++) {
+        ParmSetTorsion(uUnit->psParameters, i, sAtom1, sAtom2,
+                       sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
+        FortranWriteDouble(dScnb);
+    }
+    for (i = 0; i < iParmSetTotalImproperParms(uUnit->psParameters); i++) {
+        ParmSetImproper(uUnit->psParameters, i, sAtom1, sAtom2,
+                        sAtom3, sAtom4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc);
+        FortranWriteDouble(dScnb);
+    }
+    /* Write the torsion RESTRAINT constants AND set the index */
+    /* for where the interaction can find its constants */
+    RESTRAINTLOOP(RESTRAINTTORSION, dX0, i + 1);
+    FortranEndLine();
+	
+	/*     	    Arunima Singh	*/
+	/*    End of adding SCEE/SCNB	*/
+
     /* -18- Not used, reserved for future use, uses NATYP */
     /* Corresponds to the AMBER SOLTY array */
     FortranDebug("-18-");
@@ -6009,7 +6073,7 @@
 SAVEATOMt       *saPAtom;
 SAVETORSIONt    *stPTorsion;
 SAVERESTRAINTt  *srPRestraint;
-double          dMass, dPolar, dR, dKb, dR0, dKt, dT0, dTkub, dRkub, dKp, dP0, dC, dD, dTemp;
+double          dMass, dPolar, dR, dKb, dR0, dKt, dT0, dTkub, dRkub, dKp, dP0, dScee, dScnb, dC, dD, dTemp;
 STRING          sAtom1, sAtom2, sAtom3, sAtom4, sType1, sType2;
 int             iN, iAtoms, iMaxAtoms, iTemp, iAtom, iCalc14, iProper;
 int             iElement, iHybridization, iStart, iFirstSolvent;
@@ -6547,19 +6611,19 @@
     for ( i=0; i<iParmSetTotalTorsionParms(uUnit->psParameters); i++ ) {
         ParmSetTorsion( uUnit->psParameters, i, sAtom1, sAtom2, 
                         sAtom3, sAtom4,
-                        &iN, &dKp, &dP0, sDesc );
-        MESSAGE(( "Torsion %d  %s-%s-%s-%s %d %lf %lf\n",
+                        &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
+        MESSAGE(( "Torsion %d  %s-%s-%s-%s %d %lf %lf %lf %lf\n",
                         i, sAtom1, sAtom2, sAtom3, sAtom4,
-                        iN, dKp, dP0 ));
+                        iN, dKp, dP0, dScee, dScnb ));
         FortranWriteDouble( dKp );
     }
     for ( i=0; i<iParmSetTotalImproperParms(uUnit->psParameters); i++ ) {
         ParmSetImproper( uUnit->psParameters, i, sAtom1, sAtom2, 
                         sAtom3, sAtom4,
-                        &iN, &dKp, &dP0, sDesc );
-        MESSAGE(( "Improper %d  %s-%s-%s-%s %d %lf %lf\n",
+                        &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
+        MESSAGE(( "Improper %d  %s-%s-%s-%s %d %lf %lf %lf %lf\n",
                         i, sAtom1, sAtom2, sAtom3, sAtom4,
-                        iN, dKp, dP0 ));
+                        iN, dKp, dP0, dScee, dScnb ));
         FortranWriteDouble( dKp );
     }
                 /* Write the torsion RESTRAINT constants AND set the index */
@@ -6575,14 +6639,14 @@
     for ( i=0; i<iParmSetTotalTorsionParms(uUnit->psParameters); i++ ) {
         ParmSetTorsion( uUnit->psParameters, i, sAtom1, sAtom2, 
                         sAtom3, sAtom4,
-                        &iN, &dKp, &dP0, sDesc );
+                        &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
         dTemp = iN;
         FortranWriteDouble( dTemp );
     }
     for ( i=0; i<iParmSetTotalImproperParms(uUnit->psParameters); i++ ) {
         ParmSetImproper( uUnit->psParameters, i, sAtom1, sAtom2, 
                         sAtom3, sAtom4,
-                        &iN, &dKp, &dP0, sDesc );
+                        &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
         dTemp = iN;
         FortranWriteDouble( dTemp );
     }
@@ -6599,13 +6663,13 @@
     for ( i=0; i<iParmSetTotalTorsionParms(uUnit->psParameters); i++ ) {
         ParmSetTorsion( uUnit->psParameters, i, sAtom1, sAtom2, 
                         sAtom3, sAtom4,
-                        &iN, &dKp, &dP0, sDesc );
+                        &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
         FortranWriteDouble( dP0 );
     }
     for ( i=0; i<iParmSetTotalImproperParms(uUnit->psParameters); i++ ) {
         ParmSetImproper( uUnit->psParameters, i, sAtom1, sAtom2, 
                         sAtom3, sAtom4,
-                        &iN, &dKp, &dP0, sDesc );
+                        &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
         FortranWriteDouble( dP0 );
     }
                 /* Write the torsion RESTRAINT constants AND set the index */
diff -urN amber11//AmberTools/src/leap/src/leap/xaImproperParmTable.c amber11.new//AmberTools/src/leap/src/leap/xaImproperParmTable.c
--- amber11//AmberTools/src/leap/src/leap/xaImproperParmTable.c	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/xaImproperParmTable.c	2011-05-19 18:35:57.000000000 +0300
@@ -37,7 +37,9 @@
  *		Handle editing of parameters in a table format.
  */
 
-
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
 
 #include	<X11/IntrinsicP.h>
 #include	<X11/StringDefs.h>
@@ -59,7 +61,10 @@
 #define	NC		4
 #define	KPC		5
 #define P0C		6
-#define DESCC		7
+#define SCEE            7       /*Arunima Singh*/
+#define SCNB            8       /*Arunima Singh*/
+#define DESCC           9       /*Arunima Singh: Changed value from 7 to 9 to include scee and scnb*/
+ 
 
 #define	MAXTYPELEN	5
 #define DESCLEN		32
@@ -129,13 +134,15 @@
 int			iN;
 double			dKp;
 double			dP0;
+double			dScee;
+double			dScnb;
 char			sDesc[DESCLEN];
 
 
     iptPCur = (IMPROPERPARMTABLEt*)PXATClientPointer(tTable);
     
     ParmSetImproper( iptPCur->psParmSet, iRow, 
-	    sType1, sType2, sType3, sType4, &iN, &dKp, &dP0, sDesc );
+	    sType1, sType2, sType3, sType4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
 
     switch ( iCol ) {
 	    case TYPE1C:
@@ -171,6 +178,14 @@
 	    	}
 		return(SsBuffer);
 		break;
+            case SCEE:
+                sprintf( SsBuffer, DBLFMT, dScee );
+                return(SsBuffer);
+                break;
+            case SCNB:
+                sprintf( SsBuffer, DBLFMT, dScnb );
+                return(SsBuffer);
+                break;
 	    case DESCC:
 	    	strcpy( SsBuffer, sDesc );
 		return( SsBuffer );
@@ -259,6 +274,16 @@
 		if ( !strcmp( cPData, "0" ))  break;
 		return("P0 field must be '0' or 'Pi'.");
 		break;
+            case SCEE:
+                if ( !bStringToDouble( cPData, &dValue ) ) {
+                    return("Invalid character in Scee field.");
+                }
+                break;
+            case SCNB:
+                if ( !bStringToDouble( cPData, &dValue ) ) {
+                    return("Invalid character in Scnb field.");
+                }
+                break;
 	    case DESCC:
 		if ( strlen(cPData)>DESCLEN-1 ) {
 		    sprintf( SsError, "%s %d characters.",
@@ -384,11 +409,33 @@
 		return("P0 field must be '0' or 'Pi'.");
 	}
 
+        /*
+         *  Scee
+         */
+        *iPErrCol = 7;
+        cPData = col[7];
+        if ( !bStringToDouble( cPData, &dValue ) ) {
+                return("Invalid character in Scee field.");
+        } else if ( dValue < 0.0 ) {
+                return("Scee cannot be negative.");
+        }
+
+        /*
+         *  Scnb
+         */
+        *iPErrCol = 8;
+        cPData = col[8];
+        if ( !bStringToInt( cPData, &iValue ) ) {
+                return("Invalid character in Scnb field.");
+        } else if ( dValue < 0.0 ) {
+                return("Scnb cannot be negative.");
+        }
+
 	/*
 	 *  Desc
 	 */
-	*iPErrCol = 7;
-	cPData = col[7];
+	*iPErrCol = 9;
+	cPData = col[9];
 	if ( strlen(cPData) > DESCLEN-1 ) {
 		sprintf( SsError, "%s %d characters.",
 			"Parameter Description cannot be longer than",
@@ -413,7 +460,8 @@
 int			iN;
 double			dKp;
 double			dP0;
-
+double			dScee;
+double			dScnb;
 
 	iptPCur = (IMPROPERPARMTABLEt*) PXATClientPointer(tTable);
 	psParmSet = iptPCur->psParmSet;
@@ -444,7 +492,7 @@
 					col[0], col[1], col[2], col[3] ));
         	if ( iRow != iParmSetAddImproperTerm( psParmSet,
 					col[0], col[1], col[2], col[3],
-					iN, dKp, dP0, col[7] ) )
+					iN, dKp, dP0, dScee, dScnb, col[9] ) )
 			DFATAL(( "programming err 2 in zXAIPTAcceptRow\n" ));
 	} else {
 		/*
@@ -452,7 +500,7 @@
 		 */
 		ParmSetUpdateImproper( psParmSet, iRow, 
 				col[0], col[1], col[2], col[3],
-				&iN, &dKp, &dP0, col[7] );
+				&iN, &dKp, &dP0, &dScee, &dScnb, col[9] );
 	}
 }
 
diff -urN amber11//AmberTools/src/leap/src/leap/xaTorsionParmTable.c amber11.new//AmberTools/src/leap/src/leap/xaTorsionParmTable.c
--- amber11//AmberTools/src/leap/src/leap/xaTorsionParmTable.c	2011-03-10 20:12:06.000000000 +0200
+++ amber11.new//AmberTools/src/leap/src/leap/xaTorsionParmTable.c	2011-05-19 18:35:57.000000000 +0300
@@ -37,6 +37,9 @@
  *		Handle editing of parameters in a table format.
  */
 
+        /*      Arunima Singh (UGA)     */
+        /*         20110420             */
+        /*      Added SCEE/SCNB         */
 
 #include	<X11/IntrinsicP.h>
 #include	<X11/StringDefs.h>
@@ -58,7 +61,9 @@
 #define	NC		4
 #define	KPC		5
 #define P0C		6
-#define DESCC		7
+#define SCEE		7	/*Arunima Singh*/
+#define SCNB		8	/*Arunima Singh*/
+#define DESCC		9	/*Arunima Singh: Changed value from 7 to 9 to include scee and scnb*/
 
 #define	MAXTYPELEN	5
 #define DESCLEN		32
@@ -112,7 +117,7 @@
  *	zcPXATPTGetElement
  *
  *	Get the values for the elements of the TABLE from the
- *	particular Torsion Parmeter Entry.
+ *	particular Torsion Parameter Entry.
  */
 static char *
 zcPXATPTGetElement( TABLE tTable, int iCol, int iRow )
@@ -126,13 +131,15 @@
 int			iN;
 double			dKp;
 double			dP0;
+double			dScee;
+double			dScnb;
 char			sDesc[DESCLEN];
 
 
     tptPCur = (TORSIONPARMTABLEt*)PXATClientPointer(tTable);
     
     ParmSetTorsion( tptPCur->psParmSet, iRow, 
-	    sType1, sType2, sType3, sType4, &iN, &dKp, &dP0, sDesc );
+	    sType1, sType2, sType3, sType4, &iN, &dKp, &dP0, &dScee, &dScnb, sDesc );
     
     switch ( iCol ) {
 	    case TYPE1C:
@@ -168,6 +175,14 @@
 	    	}
 		return(SsBuffer);
 		break;
+	    case SCEE:
+		sprintf( SsBuffer, DBLFMT, dScee );
+		return(SsBuffer);
+                break;
+            case SCNB:
+                sprintf( SsBuffer, DBLFMT, dScnb );
+                return(SsBuffer);
+                break; 
 	    case DESCC:
 	    	strcpy( SsBuffer, sDesc );
 		return( SsBuffer );
@@ -256,6 +271,16 @@
 		if ( !strcmp( cPData, "0" ))  break;
 		return("P0 field must be '0' or 'Pi'.");
 		break;
+            case SCEE:
+                if ( !bStringToDouble( cPData, &dValue ) ) {
+                    return("Invalid character in Scee field.");
+                }
+                break;
+            case SCNB:
+                if ( !bStringToDouble( cPData, &dValue ) ) {
+                    return("Invalid character in Scnb field.");
+                }
+                break;
 	    case DESCC:
 		if ( strlen(cPData)>DESCLEN-1 ) {
 		    sprintf( SsError, "%s %d characters.",
@@ -379,11 +404,33 @@
 		return("P0 field must be '0' or 'Pi'.");
 	}
 
+        /*
+         *  Scee
+         */
+        *iPErrCol = 7;
+        cPData = col[7];
+        if ( !bStringToDouble( cPData, &dValue ) ) {
+                return("Invalid character in Scee field.");
+        } else if ( dValue < 0.0 ) {
+                return("Scee cannot be negative.");
+        }
+
+        /*
+         *  Scnb
+         */
+        *iPErrCol = 8;
+        cPData = col[8];
+        if ( !bStringToInt( cPData, &iValue ) ) {
+                return("Invalid character in Scnb field.");
+        } else if ( dValue < 0.0 ) {
+                return("Scnb cannot be negative.");
+        }
+
 	/*
 	 *  Desc
 	 */
-	*iPErrCol = 7;
-	cPData = col[7];
+	*iPErrCol = 9;
+	cPData = col[9];
 	if ( strlen(cPData) > DESCLEN-1 ) {
 		sprintf( SsError, "%s %d characters.",
 			"Parameter Description cannot be longer than",
@@ -408,6 +455,8 @@
 int			iN;
 double			dKp;
 double			dP0;
+double			dScee;
+double			dScnb;
 
 	tptPCur = (TORSIONPARMTABLEt*) PXATClientPointer(tTable);
 	psParmSet = tptPCur->psParmSet;
@@ -438,15 +487,15 @@
 					col[0], col[1], col[2], col[3] ));
         	if ( iRow != iParmSetAddProperTerm( psParmSet,
 					col[0], col[1], col[2], col[3],
-					iN, dKp, dP0, col[7] ) )
-			DFATAL(( "programming err 2 in zXATPTAcceptRow\n" ));
+					iN, dKp, dP0, dScee, dScnb, col[9] ) )	/*Arunima singh*/
+			DFATAL(( "programming err 2 in zXATPTAcceptRow\n" ));	
 	} else {
 		/*
 		 *  update row in place
 		 */
 		ParmSetUpdateTorsion( psParmSet, iRow, 
 				col[0], col[1], col[2], col[3],
-				&iN, &dKp, &dP0, col[7] );
+				&iN, &dKp, &dP0, &dScee, &dScnb, col[9] );	/*Arunima singh*/
 	}
 }
 
diff -urN amber11//AmberTools/src/mmpbsa_py/MMPBSA_mods/alamdcrd.py amber11.new//AmberTools/src/mmpbsa_py/MMPBSA_mods/alamdcrd.py
--- amber11//AmberTools/src/mmpbsa_py/MMPBSA_mods/alamdcrd.py	2011-04-14 15:30:17.000000000 +0300
+++ amber11.new//AmberTools/src/mmpbsa_py/MMPBSA_mods/alamdcrd.py	2011-05-19 18:35:57.000000000 +0300
@@ -371,7 +371,7 @@
          coords_received = _scaledistance(coords_tosend, chdist)
 
          for i in range(3):
-            new_coords.append(coords_received[x+3])
+            new_coords.append(coords_received[i+3])
 
          coords_tosend = []
          coords_received = []
diff -urN amber11//AmberTools/src/mmpbsa_py/setup.sh amber11.new//AmberTools/src/mmpbsa_py/setup.sh
--- amber11//AmberTools/src/mmpbsa_py/setup.sh	2011-04-14 15:30:18.000000000 +0300
+++ amber11.new//AmberTools/src/mmpbsa_py/setup.sh	2011-05-19 18:35:57.000000000 +0300
@@ -10,7 +10,8 @@
 
 # require AMBERHOME
 if [ -z $AMBERHOME ]; then
-   export AMBERHOME=`dirname \`dirname $PWD\``
+   AMBERHOME=`dirname \`dirname $PWD\``
+   export AMBERHOME=`dirname $AMBERHOME`
    echo "AMBERHOME is not set.  Assuming it is $AMBERHOME"
 fi
 
diff -urN amber11//AmberTools/test/nab/Run.prm amber11.new//AmberTools/test/nab/Run.prm
--- amber11//AmberTools/test/nab/Run.prm	2011-04-14 15:30:23.000000000 +0300
+++ amber11.new//AmberTools/test/nab/Run.prm	2011-05-19 18:35:57.000000000 +0300
@@ -17,7 +17,7 @@
 
 echo "checking the prmtop file:"
 echo ""
-tail -3209 tprmtop > tprmtop1
+tail -3228 tprmtop > tprmtop1
 ../dacdif tprmtop.check tprmtop1
 
 rm -f prm prm.c tleap.out leap.log tprmcrd prm.out1 tprmtop
diff -urN amber11//AmberTools/test/nab/tprmtop.check amber11.new//AmberTools/test/nab/tprmtop.check
--- amber11//AmberTools/test/nab/tprmtop.check	2011-03-10 20:12:18.000000000 +0200
+++ amber11.new//AmberTools/test/nab/tprmtop.check	2011-05-19 18:35:57.000000000 +0300
@@ -1,3 +1,4 @@
+%VERSION  VERSION_STAMP = V0001.000  DATE = 05/09/11  12:59:19                  
 %FLAG TITLE                                                                     
 %FORMAT(20a4)                                                                   
                                                                                 
@@ -541,6 +542,24 @@
   3.14159400E+00  3.14159400E+00  3.14159400E+00  3.14159400E+00  3.14159400E+00
   3.14159400E+00  3.14159400E+00  3.14159400E+00  3.14159400E+00  3.14159400E+00
   3.14159400E+00  3.14159400E+00  3.14159400E+00
+%FLAG SCEE_SCALE_FACTOR                                                         
+%FORMAT(5E16.8)                                                                 
+  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00
+  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00
+  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00
+  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00
+  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00
+  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00  1.20000000E+00
+  0.00000000E+00  0.00000000E+00  0.00000000E+00
+%FLAG SCNB_SCALE_FACTOR                                                         
+%FORMAT(5E16.8)                                                                 
+  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00
+  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00
+  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00
+  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00
+  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00
+  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00  2.00000000E+00
+  0.00000000E+00  0.00000000E+00  0.00000000E+00
 %FLAG SOLTY                                                                     
 %FORMAT(5E16.8)                                                                 
   0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00  0.00000000E+00
